#:include "common.fypp"

! Start timing fypp method
! We have experienced some problems with single.
! Say if the CPU is comprising a varying amount of
! efficiency vs. performance cores, then the timings
! can sometimes get negative... :(
! By enforcing a particular thread to do the timing
! we should remove this problem *fingers crossed*
#:def START_TIMING(in_teams=0)
   #:if in_teams == 0
!$omp barrier
!$omp ${OMB_OMP_MASKED}$
      call timing%start()
!$omp end ${OMB_OMP_MASKED}$
   #:else
      if (team == 0) then
         call timing%start()
      end if
   #:endif
#:enddef

#:def STOP_TIMING(var, in_teams=0)
   #:if in_teams == 0
!$omp barrier
!$omp ${OMB_OMP_MASKED}$
      call timing%stop(${var}$)
!$omp end ${OMB_OMP_MASKED}$
   #:else
      call timing%stop(${var}$)
   #:endif
#:enddef

! Short for doing type-is AND start timing
#:def TYPE_IS(name)
   type is (${name}$)
   @:START_TIMING()
#:enddef

! Since we allow multiple variations of array definitions.
! The complexity is hidden in the ARRAY_DEFINE method.
#:def ARRAY_DEFINE(dtype, size, *names)
   #:for name in names
      #:if ARRAY_IS_STACK
         real(${dtype}$) :: ${name}$ (${size}$)
      #:else
         real(${dtype}$), ${OMB_ALLOC_TYPE}$ &
            ${OMB_ARRAY_ATTRIBUTES}$ :: ${name}$ (:)
      #:endif
   #:endfor
#:enddef ARRAY_DEFINE

! Since we allow multiple variations of array definitions.
! The complexity is hidden in the ARRAY_DEALLOC method.
#:def ARRAY_DEALLOC(*names)
   #:for name in names
      #:if not ARRAY_IS_STACK
         deallocate (${name}$)
      #:endif
   #:endfor
#:enddef

module benchmarks_m

   ! Define the different methods for benchmarks
   #:if "real16" in REALS
      use iso_fortran_env, only: real16
   #:endif
   use iso_fortran_env, only: real32, real64
   #:if "real128" in REALS
      use iso_fortran_env, only: real128
   #:endif
   use iso_fortran_env, only: ${OMB_INT_KIND}$

   use omp_lib

   use options_m
   use results_m, only: results_t
   use timing_m, only: timing_t

   implicit none
   private

   integer, parameter :: UNKNOWN_METHOD_STOP = 6

   integer, public, parameter :: METHOD_NOT_SET = 0
   integer, public, parameter :: METHOD_ADD = 1
   integer, public, parameter :: METHOD_SCALE = 2
   integer, public, parameter :: METHOD_COPY = 3
   integer, public, parameter :: METHOD_TRIADD = 4
   integer, public, parameter :: METHOD_SUM = 5
   integer, public, parameter :: METHOD_AXPY = 6
   integer, public, parameter :: METHOD_FILL = 7
   integer, public, parameter :: METHOD_FALSE_SHARING_TRIADD = 8
   integer, public, parameter :: METHOD_TETRADD = 9
   integer, public, parameter :: METHOD_FALSE_SHARING_TETRADD = 10
   integer, public, parameter :: METHOD_PENTADD = 11

   #:for real in REALS
      public :: bench_add_${real}$
      public :: bench_scale_${real}$
      public :: bench_copy_${real}$
      public :: bench_triadd_${real}$
      public :: bench_tetradd_${real}$
      public :: bench_pentadd_${real}$
      public :: bench_sum_${real}$
      public :: bench_axpy_${real}$
      public :: bench_fill_${real}$
      public :: bench_false_sharing_triadd_${real}$
      public :: bench_false_sharing_tetradd_${real}$
   #:endfor

   public :: benchmark_method
   interface
      subroutine benchmark_method(n, options, results)
         use iso_fortran_env, only: ${OMB_INT_KIND}$
         use options_m, only: options_t
         use results_m, only: results_t
         integer(${OMB_INT_KIND}$), intent(in) :: n
         type(options_t), intent(in):: options
         type(results_t), intent(inout) :: results
      end subroutine
   end interface

   interface array_allocate
      #:for real in REALS
         module procedure :: array_allocate_${real}$
      #:endfor
   end interface

   interface first_touch_serial
      #:for real in REALS
         module procedure :: first_touch_serial_${real}$
      #:endfor
   end interface
   interface first_touch_parallel
      #:for real in REALS
         module procedure :: first_touch_parallel_${real}$
      #:endfor
   end interface

   interface init_array
      #:for real in REALS
         module procedure :: init_array_${real}$
      #:endfor
   end interface

   character(len=*), parameter, private :: test_fmt = "(tr1,es17.9)"

contains

   #:for real in REALS

      subroutine array_allocate_${real}$ (n, a, options)
         integer(${OMB_INT_KIND}$), intent(in) :: n
         #:if ARRAY_IS_STACK
            real(${real}$), intent(inout) :: a(n)
         #:else
            real(${real}$), dimension(:), intent(inout), ${OMB_ALLOC_TYPE}$ &
               ${OMB_ARRAY_ATTRIBUTES}$ :: a
         #:endif
         type(options_t), intent(in) :: options

         #:if not ARRAY_IS_STACK
!$omp ${OMB_OMP_MASKED}$
            #:if ARRAY_IS_POINTER
               nullify (a)
            #:endif

            #:if not ARRAY_IS_STACK
               ! Allocate etc.
               allocate (a(n + options%offset))
            #:endif
!$omp end ${OMB_OMP_MASKED}$

! Ensure we have it allocated before use
!$omp barrier

         #:endif

      end subroutine

      subroutine first_touch_parallel_${real}$ (n, a, v)
         integer(${OMB_INT_KIND}$), intent(in) :: n
         real(${real}$), intent(inout) :: a(n)
         real(${real}$), intent(in) :: v

         integer(${OMB_INT_KIND}$) :: i

!$omp do schedule(runtime)
         do i = 1, n
            a(i) = v
         end do
!$omp end do

      end subroutine

      subroutine first_touch_serial_${real}$ (n, a, v)
         integer(${OMB_INT_KIND}$), intent(in) :: n
         real(${real}$), intent(inout) :: a(n)
         real(${real}$), intent(in) :: v

         integer(${OMB_INT_KIND}$) :: i

!$omp ${OMB_OMP_MASKED}$
         do i = 1, n
            a(i) = v
         end do
!$omp end ${OMB_OMP_MASKED}$

!$omp barrier

      end subroutine

      subroutine init_array_${real}$ (n, a, v, options)
         integer(${OMB_INT_KIND}$), intent(in) :: n
         type(options_t), intent(in):: options
         real(${real}$), intent(inout) :: a(n + options%offset)
         real(${real}$), intent(in) :: v

         integer(${OMB_INT_KIND}$) :: i
         real(${real}$) :: sum
         integer :: it

         if (options%first_touch) then
            call first_touch_parallel(n + options%offset, a, v)
         else
            call first_touch_serial(n + options%offset, a, v)
         end if

         do it = 1, options%warmup_it
            sum = 0._${real}$
            ! We can't do a reduction on the sum
            ! variable, since it is an orphaned
            ! method.
!$omp do schedule(runtime) private(sum)
            do i = 1, n
               sum = sum + a(i)
            end do
!$omp end do
         end do

      end subroutine

      ! Beginning of benchmark methods

      subroutine bench_sum_${real}$ (n, options, results)
         integer(${OMB_INT_KIND}$), intent(in) :: n
         type(options_t), intent(in):: options
         type(results_t), intent(inout) :: results

         integer(${OMB_INT_KIND}$) :: i, istart, iend
         integer :: it, team
         type(timing_t) :: timing

         real(${real}$) :: sum_a
         @:ARRAY_DEFINE(${real}$, n + options%offset, a)

!$omp parallel
         call array_allocate(n, a, options)
         call init_array(n, a, 0.5_${real}$, options)
!$omp end parallel

         if (options%test) then
            write (*, test_fmt, advance="no") sum(a(1:n)) - n*0.5_${real}$
         end if

         select type (kernel => options%kernel)

         type is (option_kernel_serial_t)

            do it = 1, options%it
               call timing%start()
               sum_a = 0._${real}$
               do i = 1, n
                  sum_a = sum_a + a(i)
               end do
               call timing%stop(results%times(it))
            end do

            #:if defined("OMB_OMP_TEAMS")
               type is (option_kernel_teams_manual_t)
!$omp teams private(it,i,team,istart,iend) &
!$omp&  num_teams(options%num_threads) thread_limit(1) &
!$omp&  reduction(+:sum_a)
               call manual_split(n, istart, iend, in_teams=.true.)

               team = omp_get_team_num()

               do it = 1, options%it

                  @:START_TIMING(in_teams=1)

                  ! Since we are doing this options%it times, we have to 0
                  sum_a = 0._${real}$
                  do i = istart, iend
                     sum_a = sum_a + a(i)
                  end do

                  @:STOP_TIMING(results%times(it), in_teams=1)

               end do

!$omp end teams

               #:if defined("OMB_OMP_TEAMS_DISTRIBUTE")
                  type is (option_kernel_teams_distribute_t)
!$omp teams private(it,i,team) &
!$omp&  num_teams(options%num_threads) thread_limit(1) &
!$omp&  reduction(+:sum_a)

                  team = omp_get_team_num()

                  do it = 1, options%it

                     @:START_TIMING(in_teams=1)

                     sum_a = 0._${real}$
!$omp distribute dist_schedule(static)
                     do i = 1, n
                        sum_a = sum_a + a(i)
                     end do
!$omp end distribute

                     @:STOP_TIMING(results%times(it), in_teams=1)

                  end do

!$omp end teams

                  type is (option_kernel_teams_distribute_do_t)
!$omp teams private(it,i,team) &
!$omp&  num_teams(options%num_threads) thread_limit(1)

                  team = omp_get_team_num()

                  do it = 1, options%it

                     @:START_TIMING(in_teams=1)

!$omp distribute parallel do dist_schedule(static) &
!$omp&  reduction(+:sum_a)
                     do i = 1, n
                        sum_a = sum_a + a(i)
                     end do
!$omp end distribute parallel do

                     @:STOP_TIMING(results%times(it), in_teams=1)

                  end do

!$omp end teams
               #:endif

               #:if defined("OMB_OMP_TEAMS_PARALLEL")
                  type is (option_kernel_teams_parallel_manual_t)
!$omp teams private(it,i,istart,iend) &
!$omp&  num_teams(1) thread_limit(options%num_threads)

!$omp parallel private(it,i,istart,iend) &
!$omp&  reduction(+:sum_a)
                  call manual_split(n, istart, iend)

                  do it = 1, options%it

                     @:START_TIMING()

                     sum_a = 0._${real}$
                     do i = istart, iend
                        sum_a = sum_a + a(i)
                     end do

                     @:STOP_TIMING(results%times(it))

                  end do
!$omp end parallel

!$omp end teams

                  type is (option_kernel_teams_parallel_do_t)
!$omp teams private(it,i,team) &
!$omp&  num_teams(1) thread_limit(options%num_threads)

                  team = omp_get_team_num()

                  do it = 1, options%it

                     @:START_TIMING(in_teams=1)

!$omp parallel do schedule(runtime) &
!$omp&  reduction(+:sum_a)
                     do i = 1, n
                        sum_a = sum_a + a(i)
                     end do
!$omp end parallel do

                     @:STOP_TIMING(results%times(it), in_teams=1)

                  end do

!$omp end teams

                  type is (option_kernel_teams_parallel_loop_t)
!$omp teams private(it,i,team) &
!$omp&  num_teams(1) thread_limit(options%num_threads)

                  team = omp_get_team_num()

                  do it = 1, options%it

                     @:START_TIMING(in_teams=1)

!$omp parallel
!$omp loop reduction(+:sum_a)
                     do i = 1, n
                        sum_a = sum_a + a(i)
                     end do
!$omp end loop
!$omp end parallel

                     @:STOP_TIMING(results%times(it), in_teams=1)

                  end do

!$omp end teams
               #:endif
            #:endif

         class default

!$omp parallel private(it,i,istart,iend)
            call manual_split(n, istart, iend)

            do it = 1, options%it

               select type (kernel => options%kernel)

                  @:TYPE_IS(option_kernel_manual_t)
                  do i = istart, iend
                     sum_a = sum_a + a(i)
                  end do

                  @:TYPE_IS(option_kernel_do_t)
!$omp do schedule(runtime) reduction(+:sum_a)
                  do i = 1, n
                     sum_a = sum_a + a(i)
                  end do
!$omp end do

                  @:TYPE_IS(option_kernel_do_simd_t)
!$omp do simd schedule(runtime) reduction(+:sum_a)
                  do i = 1, n
                     sum_a = sum_a + a(i)
                  end do
!$omp end do simd

                  @:TYPE_IS(option_kernel_workshare_t)
!$omp workshare
                  sum_a = sum(a(1:n))
!$omp end workshare

                  #:if defined("OMB_OMP_TASKLOOP")
                     @:TYPE_IS(option_kernel_taskloop_t)
!$omp single
!$omp taskloop num_tasks(kernel%num_tasks) &
!$omp&  reduction(+:sum_a)
                     do i = 1, n
                        sum_a = sum_a + a(i)
                     end do
!$omp end taskloop
!$omp end single

                     @:TYPE_IS(option_kernel_taskloop_simd_t)
!$omp single
!$omp taskloop simd num_tasks(kernel%num_tasks) &
!$omp&  reduction(+:sum_a)
                     do i = 1, n
                        sum_a = sum_a + a(i)
                     end do
!$omp end taskloop simd
!$omp end single
                  #:endif

                  @:TYPE_IS(option_kernel_loop_t)
!$omp loop reduction(+:sum_a)
                  do i = 1, n
                     sum_a = sum_a + a(i)
                  end do
!$omp end loop

               class default

                  stop UNKNOWN_METHOD_STOP

               end select

               @:STOP_TIMING(results%times(it))

            end do

!$omp end parallel

         end select

         call results%update(1, n, 1, storage_size(1.0_${real}$))

         if (options%test) then
            write (*, test_fmt) sum(a(1:n)) - n*0.5_${real}$
         end if

         @:ARRAY_DEALLOC(a)

      end subroutine

      subroutine bench_fill_${real}$ (n, options, results)
         integer(${OMB_INT_KIND}$), intent(in) :: n
         type(options_t), intent(in):: options
         type(results_t), intent(inout) :: results

         integer(${OMB_INT_KIND}$) :: i, istart, iend
         integer :: it, team
         type(timing_t) :: timing

         real(${real}$) :: fill
         @:ARRAY_DEFINE(${real}$, n + options%offset, a)

         fill = 2._${real}$

!$omp parallel
         call array_allocate(n, a, options)
         call init_array(n, a, 0.5_${real}$, options)
!$omp end parallel

         if (options%test) then
            write (*, test_fmt, advance="no") sum(a(1:n)) - n*0.5_${real}$
         end if

         select type (kernel => options%kernel)

         type is (option_kernel_serial_t)

            do it = 1, options%it
               call timing%start()
               do i = 1, n
                  a(i) = fill
               end do
               call timing%stop(results%times(it))
            end do

            #:if defined("OMB_OMP_TEAMS")
               type is (option_kernel_teams_manual_t)
!$omp teams private(it,i,team,istart,iend) &
!$omp&  num_teams(options%num_threads) thread_limit(1)
               call manual_split(n, istart, iend, in_teams=.true.)

               team = omp_get_team_num()

               do it = 1, options%it

                  @:START_TIMING(in_teams=1)

                  do i = istart, iend
                     a(i) = fill
                  end do

                  @:STOP_TIMING(results%times(it), in_teams=1)

               end do

!$omp end teams

               #:if defined("OMB_OMP_TEAMS_DISTRIBUTE")
                  type is (option_kernel_teams_distribute_t)
!$omp teams private(it,i,team) &
!$omp&  num_teams(options%num_threads) thread_limit(1)

                  team = omp_get_team_num()

                  do it = 1, options%it

                     @:START_TIMING(in_teams=1)

!$omp distribute dist_schedule(static)
                     do i = 1, n
                        a(i) = fill
                     end do
!$omp end distribute

                     @:STOP_TIMING(results%times(it), in_teams=1)

                  end do

!$omp end teams

                  type is (option_kernel_teams_distribute_do_t)
!$omp teams private(it,i,team) &
!$omp&  num_teams(options%num_threads) thread_limit(1)

                  team = omp_get_team_num()

                  do it = 1, options%it

                     @:START_TIMING(in_teams=1)

!$omp distribute parallel do dist_schedule(static)
                     do i = 1, n
                        a(i) = fill
                     end do
!$omp end distribute parallel do

                     @:STOP_TIMING(results%times(it), in_teams=1)

                  end do

!$omp end teams
               #:endif

               #:if defined("OMB_OMP_TEAMS_PARALLEL")
                  type is (option_kernel_teams_parallel_manual_t)
!$omp teams private(it,i,istart,iend) &
!$omp&  num_teams(1) thread_limit(options%num_threads)

!$omp parallel private(it,i,istart,iend)
                  call manual_split(n, istart, iend)

                  do it = 1, options%it

                     @:START_TIMING()

                     do i = istart, iend
                        a(i) = fill
                     end do

                     @:STOP_TIMING(results%times(it))

                  end do
!$omp end parallel

!$omp end teams

                  type is (option_kernel_teams_parallel_do_t)
!$omp teams private(it,i,team) &
!$omp&  num_teams(1) thread_limit(options%num_threads)

                  team = omp_get_team_num()

                  do it = 1, options%it

                     @:START_TIMING(in_teams=1)

!$omp parallel do schedule(runtime)
                     do i = 1, n
                        a(i) = fill
                     end do
!$omp end parallel do

                     @:STOP_TIMING(results%times(it), in_teams=1)

                  end do

!$omp end teams

                  type is (option_kernel_teams_parallel_loop_t)
!$omp teams private(it,i,team) &
!$omp&  num_teams(1) thread_limit(options%num_threads)

                  team = omp_get_team_num()

                  do it = 1, options%it

                     @:START_TIMING(in_teams=1)

!$omp parallel
!$omp loop
                     do i = 1, n
                        a(i) = fill
                     end do
!$omp end loop
!$omp end parallel

                     @:STOP_TIMING(results%times(it), in_teams=1)

                  end do

!$omp end teams
               #:endif
            #:endif

         class default

!$omp parallel private(it,i,istart,iend)
            call manual_split(n, istart, iend)

            do it = 1, options%it

               select type (kernel => options%kernel)

                  @:TYPE_IS(option_kernel_manual_t)
                  do i = istart, iend
                     a(i) = fill
                  end do

                  @:TYPE_IS(option_kernel_do_t)
!$omp do schedule(runtime)
                  do i = 1, n
                     a(i) = fill
                  end do
!$omp end do

                  @:TYPE_IS(option_kernel_do_simd_t)
!$omp do simd schedule(runtime)
                  do i = 1, n
                     a(i) = fill
                  end do
!$omp end do simd

                  @:TYPE_IS(option_kernel_workshare_t)
!$omp workshare
                  a(1:n) = fill
!$omp end workshare

                  #:if defined("OMB_OMP_TASKLOOP")
                     @:TYPE_IS(option_kernel_taskloop_t)
!$omp single
!$omp taskloop num_tasks(kernel%num_tasks)
                     do i = 1, n
                        a(i) = fill
                     end do
!$omp end taskloop
!$omp end single

                     @:TYPE_IS(option_kernel_taskloop_simd_t)
!$omp single
!$omp taskloop simd num_tasks(kernel%num_tasks)
                     do i = 1, n
                        a(i) = fill
                     end do
!$omp end taskloop simd
!$omp end single
                  #:endif

                  @:TYPE_IS(option_kernel_loop_t)
!$omp loop
                  do i = 1, n
                     a(i) = fill
                  end do
!$omp end loop

               class default

                  stop UNKNOWN_METHOD_STOP

               end select

               @:STOP_TIMING(results%times(it))

            end do

!$omp end parallel

         end select

         call results%update(1, n, 0, storage_size(1.0_${real}$))

         if (options%test) then
            write (*, test_fmt) sum(a(1:n)) - n*fill
         end if

         @:ARRAY_DEALLOC(a)

      end subroutine

      subroutine bench_copy_${real}$ (n, options, results)
         integer(${OMB_INT_KIND}$), intent(in) :: n
         type(options_t), intent(in):: options
         type(results_t), intent(inout) :: results

         integer(${OMB_INT_KIND}$) :: i, istart, iend
         integer :: it, team
         type(timing_t) :: timing

         @:ARRAY_DEFINE(${real}$, n + options%offset, a, b)

!$omp parallel
         call array_allocate(n, a, options)
         call array_allocate(n, b, options)
         call init_array(n, a, 0.5_${real}$, options)
         call init_array(n, b, 1.5_${real}$, options)
!$omp end parallel

         if (options%test) then
            write (*, test_fmt, advance="no") sum(a(1:n)) - n*0.5_${real}$
         end if

         select type (kernel => options%kernel)

         type is (option_kernel_serial_t)

            do it = 1, options%it
               call timing%start()
               do i = 1, n
                  a(i) = b(i)
               end do
               call timing%stop(results%times(it))
            end do

            #:if defined("OMB_OMP_TEAMS")
               type is (option_kernel_teams_manual_t)
!$omp teams private(it,i,team,istart,iend) &
!$omp&  num_teams(options%num_threads) thread_limit(1)
               call manual_split(n, istart, iend, in_teams=.true.)

               team = omp_get_team_num()

               do it = 1, options%it

                  @:START_TIMING(in_teams=1)

                  do i = istart, iend
                     a(i) = b(i)
                  end do

                  @:STOP_TIMING(results%times(it), in_teams=1)

               end do

!$omp end teams

               #:if defined("OMB_OMP_TEAMS_DISTRIBUTE")
                  type is (option_kernel_teams_distribute_t)
!$omp teams private(it,i,team) &
!$omp&  num_teams(options%num_threads) thread_limit(1)

                  team = omp_get_team_num()

                  do it = 1, options%it

                     @:START_TIMING(in_teams=1)

!$omp distribute dist_schedule(static)
                     do i = 1, n
                        a(i) = b(i)
                     end do
!$omp end distribute

                     @:STOP_TIMING(results%times(it), in_teams=1)

                  end do

!$omp end teams

                  type is (option_kernel_teams_distribute_do_t)
!$omp teams private(it,i,team) &
!$omp&  num_teams(options%num_threads) thread_limit(1)

                  team = omp_get_team_num()

                  do it = 1, options%it

                     @:START_TIMING(in_teams=1)

!$omp distribute parallel do dist_schedule(static)
                     do i = 1, n
                        a(i) = b(i)
                     end do
!$omp end distribute parallel do

                     @:STOP_TIMING(results%times(it), in_teams=1)

                  end do

!$omp end teams
               #:endif

               #:if defined("OMB_OMP_TEAMS_PARALLEL")
                  type is (option_kernel_teams_parallel_manual_t)
!$omp teams private(it,i,istart,iend) &
!$omp&  num_teams(1) thread_limit(options%num_threads)

!$omp parallel private(it,i,istart,iend)
                  call manual_split(n, istart, iend)

                  do it = 1, options%it

                     @:START_TIMING()

                     do i = istart, iend
                        a(i) = b(i)
                     end do

                     @:STOP_TIMING(results%times(it))

                  end do
!$omp end parallel

!$omp end teams

                  type is (option_kernel_teams_parallel_do_t)
!$omp teams private(it,i,team) &
!$omp&  num_teams(1) thread_limit(options%num_threads)

                  team = omp_get_team_num()

                  do it = 1, options%it

                     @:START_TIMING(in_teams=1)

!$omp parallel do schedule(runtime)
                     do i = 1, n
                        a(i) = b(i)
                     end do
!$omp end parallel do

                     @:STOP_TIMING(results%times(it), in_teams=1)

                  end do

!$omp end teams

                  type is (option_kernel_teams_parallel_loop_t)
!$omp teams private(it,i,team) &
!$omp&  num_teams(1) thread_limit(options%num_threads)

                  team = omp_get_team_num()

                  do it = 1, options%it

                     @:START_TIMING(in_teams=1)

!$omp parallel
!$omp loop
                     do i = 1, n
                        a(i) = b(i)
                     end do
!$omp end loop
!$omp end parallel

                     @:STOP_TIMING(results%times(it), in_teams=1)

                  end do

!$omp end teams
               #:endif
            #:endif

         class default

!$omp parallel private(it,i,istart,iend)
            call manual_split(n, istart, iend)

            do it = 1, options%it

               select type (kernel => options%kernel)

                  @:TYPE_IS(option_kernel_manual_t)
                  do i = istart, iend
                     a(i) = b(i)
                  end do

                  @:TYPE_IS(option_kernel_do_t)
!$omp do schedule(runtime)
                  do i = 1, n
                     a(i) = b(i)
                  end do
!$omp end do

                  @:TYPE_IS(option_kernel_do_simd_t)
!$omp do simd schedule(runtime)
                  do i = 1, n
                     a(i) = b(i)
                  end do
!$omp end do simd

                  @:TYPE_IS(option_kernel_workshare_t)
!$omp workshare
                  a(1:n) = b(1:n)
!$omp end workshare

                  #:if defined("OMB_OMP_TASKLOOP")
                     @:TYPE_IS(option_kernel_taskloop_t)
!$omp single
!$omp taskloop num_tasks(kernel%num_tasks)
                     do i = 1, n
                        a(i) = b(i)
                     end do
!$omp end taskloop
!$omp end single

                     @:TYPE_IS(option_kernel_taskloop_simd_t)
!$omp single
!$omp taskloop simd num_tasks(kernel%num_tasks)
                     do i = 1, n
                        a(i) = b(i)
                     end do
!$omp end taskloop simd
!$omp end single
                  #:endif

                  @:TYPE_IS(option_kernel_loop_t)
!$omp loop
                  do i = 1, n
                     a(i) = b(i)
                  end do
!$omp end loop

               class default

                  stop UNKNOWN_METHOD_STOP

               end select

               @:STOP_TIMING(results%times(it))

            end do

!$omp end parallel

         end select

         call results%update(2, n, 0, storage_size(1.0_${real}$))

         if (options%test) then
            write (*, test_fmt) sum(a(1:n)) - n*1.5_${real}$
         end if

         @:ARRAY_DEALLOC(a, b)

      end subroutine

      subroutine bench_scale_${real}$ (n, options, results)
         integer(${OMB_INT_KIND}$), intent(in) :: n
         type(options_t), intent(in):: options
         type(results_t), intent(inout) :: results

         integer(${OMB_INT_KIND}$) :: i, istart, iend
         integer :: it, team
         type(timing_t) :: timing

         real(${real}$) :: scale
         @:ARRAY_DEFINE(${real}$, n + options%offset, a, b)

         scale = 2._${real}$

!$omp parallel
         call array_allocate(n, a, options)
         call array_allocate(n, b, options)
         call init_array(n, a, 0.5_${real}$, options)
         call init_array(n, b, 1.5_${real}$, options)
!$omp end parallel

         if (options%test) then
            write (*, test_fmt, advance="no") sum(a(1:n)) - n*0.5_${real}$
         end if

         select type (kernel => options%kernel)

         type is (option_kernel_serial_t)

            do it = 1, options%it
               call timing%start()
               do i = 1, n
                  a(i) = scale*b(i)
               end do
               call timing%stop(results%times(it))
            end do

            #:if defined("OMB_OMP_TEAMS")
               type is (option_kernel_teams_manual_t)
!$omp teams private(it,i,team,istart,iend) &
!$omp&  num_teams(options%num_threads) thread_limit(1)
               call manual_split(n, istart, iend, in_teams=.true.)

               team = omp_get_team_num()

               do it = 1, options%it

                  @:START_TIMING(in_teams=1)

                  do i = istart, iend
                     a(i) = scale*b(i)
                  end do

                  @:STOP_TIMING(results%times(it), in_teams=1)

               end do

!$omp end teams

               #:if defined("OMB_OMP_TEAMS_DISTRIBUTE")
                  type is (option_kernel_teams_distribute_t)
!$omp teams private(it,i,team) &
!$omp&  num_teams(options%num_threads) thread_limit(1)

                  team = omp_get_team_num()

                  do it = 1, options%it

                     @:START_TIMING(in_teams=1)

!$omp distribute dist_schedule(static)
                     do i = 1, n
                        a(i) = scale*b(i)
                     end do
!$omp end distribute

                     @:STOP_TIMING(results%times(it), in_teams=1)

                  end do

!$omp end teams

                  type is (option_kernel_teams_distribute_do_t)
!$omp teams private(it,i,team) &
!$omp&  num_teams(options%num_threads) thread_limit(1)

                  team = omp_get_team_num()

                  do it = 1, options%it

                     @:START_TIMING(in_teams=1)

!$omp distribute parallel do dist_schedule(static)
                     do i = 1, n
                        a(i) = scale*b(i)
                     end do
!$omp end distribute parallel do

                     @:STOP_TIMING(results%times(it), in_teams=1)

                  end do

!$omp end teams
               #:endif

               #:if defined("OMB_OMP_TEAMS_PARALLEL")
                  type is (option_kernel_teams_parallel_manual_t)
!$omp teams private(it,i,istart,iend) &
!$omp&  num_teams(1) thread_limit(options%num_threads)

!$omp parallel private(it,i,istart,iend)
                  call manual_split(n, istart, iend)

                  do it = 1, options%it

                     @:START_TIMING()

                     do i = istart, iend
                        a(i) = scale*b(i)
                     end do

                     @:STOP_TIMING(results%times(it))

                  end do
!$omp end parallel

!$omp end teams

                  type is (option_kernel_teams_parallel_do_t)
!$omp teams private(it,i,team) &
!$omp&  num_teams(1) thread_limit(options%num_threads)

                  team = omp_get_team_num()

                  do it = 1, options%it

                     @:START_TIMING(in_teams=1)

!$omp parallel do schedule(runtime)
                     do i = 1, n
                        a(i) = scale*b(i)
                     end do
!$omp end parallel do

                     @:STOP_TIMING(results%times(it), in_teams=1)

                  end do

!$omp end teams

                  type is (option_kernel_teams_parallel_loop_t)
!$omp teams private(it,i,team) &
!$omp&  num_teams(1) thread_limit(options%num_threads)

                  team = omp_get_team_num()

                  do it = 1, options%it

                     @:START_TIMING(in_teams=1)

!$omp parallel
!$omp loop
                     do i = 1, n
                        a(i) = scale*b(i)
                     end do
!$omp end loop
!$omp end parallel

                     @:STOP_TIMING(results%times(it), in_teams=1)

                  end do

!$omp end teams
               #:endif
            #:endif

         class default

!$omp parallel private(it,i,istart,iend)
            call manual_split(n, istart, iend)

            do it = 1, options%it

               select type (kernel => options%kernel)

                  @:TYPE_IS(option_kernel_manual_t)
                  do i = istart, iend
                     a(i) = scale*b(i)
                  end do

                  @:TYPE_IS(option_kernel_do_t)
!$omp do schedule(runtime)
                  do i = 1, n
                     a(i) = scale*b(i)
                  end do
!$omp end do

                  @:TYPE_IS(option_kernel_do_simd_t)
!$omp do simd schedule(runtime)
                  do i = 1, n
                     a(i) = scale*b(i)
                  end do
!$omp end do simd

                  @:TYPE_IS(option_kernel_workshare_t)
!$omp workshare
                  a(1:n) = scale*b(1:n)
!$omp end workshare

                  #:if defined("OMB_OMP_TASKLOOP")
                     @:TYPE_IS(option_kernel_taskloop_t)
!$omp single
!$omp taskloop num_tasks(kernel%num_tasks)
                     do i = 1, n
                        a(i) = scale*b(i)
                     end do
!$omp end taskloop
!$omp end single

                     @:TYPE_IS(option_kernel_taskloop_simd_t)
!$omp single
!$omp taskloop simd num_tasks(kernel%num_tasks)
                     do i = 1, n
                        a(i) = scale*b(i)
                     end do
!$omp end taskloop simd
!$omp end single
                  #:endif

                  @:TYPE_IS(option_kernel_loop_t)
!$omp loop
                  do i = 1, n
                     a(i) = scale*b(i)
                  end do
!$omp end loop

               class default

                  stop UNKNOWN_METHOD_STOP

               end select

               @:STOP_TIMING(results%times(it))

            end do

!$omp end parallel

         end select

         call results%update(2, n, 1, storage_size(1.0_${real}$))

         if (options%test) then
            write (*, test_fmt) sum(a(1:n)) - n*scale*1.5_${real}$
         end if

         @:ARRAY_DEALLOC(a, b)

      end subroutine

      subroutine bench_add_${real}$ (n, options, results)
         integer(${OMB_INT_KIND}$), intent(in) :: n
         type(options_t), intent(in):: options
         type(results_t), intent(inout) :: results

         integer(${OMB_INT_KIND}$) :: i, istart, iend
         integer :: it, team
         type(timing_t) :: timing

         @:ARRAY_DEFINE(${real}$, n + options%offset, a, b, c)

!$omp parallel
         call array_allocate(n, a, options)
         call array_allocate(n, b, options)
         call array_allocate(n, c, options)
         call init_array(n, a, 0.5_${real}$, options)
         call init_array(n, b, 1.5_${real}$, options)
         call init_array(n, c, 2.5_${real}$, options)
!$omp end parallel

         if (options%test) then
            write (*, test_fmt, advance="no") sum(a(1:n)) - n*0.5_${real}$
         end if

         select type (kernel => options%kernel)

         type is (option_kernel_serial_t)

            do it = 1, options%it
               call timing%start()
               do i = 1, n
                  a(i) = b(i) + c(i)
               end do
               call timing%stop(results%times(it))
            end do

            #:if defined("OMB_OMP_TEAMS")
               type is (option_kernel_teams_manual_t)
!$omp teams private(it,i,team,istart,iend) &
!$omp&  num_teams(options%num_threads) thread_limit(1)
               call manual_split(n, istart, iend, in_teams=.true.)

               team = omp_get_team_num()

               do it = 1, options%it

                  @:START_TIMING(in_teams=1)

                  do i = istart, iend
                     a(i) = b(i) + c(i)
                  end do

                  @:STOP_TIMING(results%times(it), in_teams=1)

               end do

!$omp end teams

               #:if defined("OMB_OMP_TEAMS_DISTRIBUTE")
                  type is (option_kernel_teams_distribute_t)
!$omp teams private(it,i,team) &
!$omp&  num_teams(options%num_threads) thread_limit(1)

                  team = omp_get_team_num()

                  do it = 1, options%it

                     @:START_TIMING(in_teams=1)

!$omp distribute dist_schedule(static)
                     do i = 1, n
                        a(i) = b(i) + c(i)
                     end do
!$omp end distribute

                     @:STOP_TIMING(results%times(it), in_teams=1)

                  end do

!$omp end teams

                  type is (option_kernel_teams_distribute_do_t)
!$omp teams private(it,i,team) &
!$omp&  num_teams(options%num_threads) thread_limit(1)

                  team = omp_get_team_num()

                  do it = 1, options%it

                     @:START_TIMING(in_teams=1)

!$omp distribute parallel do dist_schedule(static)
                     do i = 1, n
                        a(i) = b(i) + c(i)
                     end do
!$omp end distribute parallel do

                     @:STOP_TIMING(results%times(it), in_teams=1)

                  end do

!$omp end teams
               #:endif

               #:if defined("OMB_OMP_TEAMS_PARALLEL")
                  type is (option_kernel_teams_parallel_manual_t)
!$omp teams private(it,i,istart,iend) &
!$omp&  num_teams(1) thread_limit(options%num_threads)

!$omp parallel private(it,i,istart,iend)
                  call manual_split(n, istart, iend)

                  do it = 1, options%it

                     @:START_TIMING()

                     do i = istart, iend
                        a(i) = b(i) + c(i)
                     end do

                     @:STOP_TIMING(results%times(it))

                  end do
!$omp end parallel

!$omp end teams

                  type is (option_kernel_teams_parallel_do_t)
!$omp teams private(it,i,team) &
!$omp&  num_teams(1) thread_limit(options%num_threads)

                  team = omp_get_team_num()

                  do it = 1, options%it

                     @:START_TIMING(in_teams=1)

!$omp parallel do schedule(runtime)
                     do i = 1, n
                        a(i) = b(i) + c(i)
                     end do
!$omp end parallel do

                     @:STOP_TIMING(results%times(it), in_teams=1)

                  end do

!$omp end teams

                  type is (option_kernel_teams_parallel_loop_t)
!$omp teams private(it,i,team) &
!$omp&  num_teams(1) thread_limit(options%num_threads)

                  team = omp_get_team_num()

                  do it = 1, options%it

                     @:START_TIMING(in_teams=1)

!$omp parallel
!$omp loop
                     do i = 1, n
                        a(i) = b(i) + c(i)
                     end do
!$omp end loop
!$omp end parallel

                     @:STOP_TIMING(results%times(it), in_teams=1)

                  end do

!$omp end teams
               #:endif
            #:endif

         class default

!$omp parallel private(it,i,istart,iend)
            call manual_split(n, istart, iend)

            do it = 1, options%it

               select type (kernel => options%kernel)

                  @:TYPE_IS(option_kernel_manual_t)
                  do i = istart, iend
                     a(i) = b(i) + c(i)
                  end do

                  @:TYPE_IS(option_kernel_do_t)
!$omp do schedule(runtime)
                  do i = 1, n
                     a(i) = b(i) + c(i)
                  end do
!$omp end do

                  @:TYPE_IS(option_kernel_do_simd_t)
!$omp do simd schedule(runtime)
                  do i = 1, n
                     a(i) = b(i) + c(i)
                  end do
!$omp end do simd

                  @:TYPE_IS(option_kernel_workshare_t)
!$omp workshare
                  a(1:n) = b(1:n) + c(1:n)
!$omp end workshare

                  #:if defined("OMB_OMP_TASKLOOP")
                     @:TYPE_IS(option_kernel_taskloop_t)
!$omp single
!$omp taskloop num_tasks(kernel%num_tasks)
                     do i = 1, n
                        a(i) = b(i) + c(i)
                     end do
!$omp end taskloop
!$omp end single

                     @:TYPE_IS(option_kernel_taskloop_simd_t)
!$omp single
!$omp taskloop simd num_tasks(kernel%num_tasks)
                     do i = 1, n
                        a(i) = b(i) + c(i)
                     end do
!$omp end taskloop simd
!$omp end single
                  #:endif

                  @:TYPE_IS(option_kernel_loop_t)
!$omp loop
                  do i = 1, n
                     a(i) = b(i) + c(i)
                  end do
!$omp end loop

               class default

                  stop UNKNOWN_METHOD_STOP

               end select

               @:STOP_TIMING(results%times(it))

            end do

!$omp end parallel

         end select

         call results%update(3, n, 1, storage_size(1.0_${real}$))

         if (options%test) then
            write (*, test_fmt) sum(a(1:n)) - n*(1.5_${real}$+2.5_${real}$)
         end if

         @:ARRAY_DEALLOC(a, b, c)

      end subroutine

      subroutine bench_triadd_${real}$ (n, options, results)
         integer(${OMB_INT_KIND}$), intent(in) :: n
         type(options_t), intent(in):: options
         type(results_t), intent(inout) :: results

         integer(${OMB_INT_KIND}$) :: i, istart, iend
         integer :: it, team
         type(timing_t) :: timing

         real(${real}$) :: scale
         @:ARRAY_DEFINE(${real}$, n + options%offset, a, b, c)

         scale = 2._${real}$

!$omp parallel
         call array_allocate(n, a, options)
         call array_allocate(n, b, options)
         call array_allocate(n, c, options)
         call init_array(n, a, 0.5_${real}$, options)
         call init_array(n, b, 1.5_${real}$, options)
         call init_array(n, c, 2.5_${real}$, options)
!$omp end parallel

         if (options%test) then
            write (*, test_fmt, advance="no") sum(a(1:n)) - n*0.5_${real}$
         end if

         select type (kernel => options%kernel)

         type is (option_kernel_serial_t)

            do it = 1, options%it
               call timing%start()
               do i = 1, n
                  a(i) = b(i) + scale*c(i)
               end do
               call timing%stop(results%times(it))
            end do

            #:if defined("OMB_OMP_TEAMS")
               type is (option_kernel_teams_manual_t)
!$omp teams private(it,i,team,istart,iend) &
!$omp&  num_teams(options%num_threads) thread_limit(1)
               call manual_split(n, istart, iend, in_teams=.true.)

               team = omp_get_team_num()

               do it = 1, options%it

                  @:START_TIMING(in_teams=1)

                  do i = istart, iend
                     a(i) = b(i) + scale*c(i)
                  end do

                  @:STOP_TIMING(results%times(it), in_teams=1)

               end do

!$omp end teams

               #:if defined("OMB_OMP_TEAMS_DISTRIBUTE")
                  type is (option_kernel_teams_distribute_t)
!$omp teams private(it,i,team) &
!$omp&  num_teams(options%num_threads) thread_limit(1)

                  team = omp_get_team_num()

                  do it = 1, options%it

                     @:START_TIMING(in_teams=1)

!$omp distribute dist_schedule(static)
                     do i = 1, n
                        a(i) = b(i) + scale*c(i)
                     end do
!$omp end distribute

                     @:STOP_TIMING(results%times(it), in_teams=1)

                  end do

!$omp end teams

                  type is (option_kernel_teams_distribute_do_t)
!$omp teams private(it,i,team) &
!$omp&  num_teams(options%num_threads) thread_limit(1)

                  team = omp_get_team_num()

                  do it = 1, options%it

                     @:START_TIMING(in_teams=1)

!$omp distribute parallel do dist_schedule(static)
                     do i = 1, n
                        a(i) = b(i) + scale*c(i)
                     end do
!$omp end distribute parallel do

                     @:STOP_TIMING(results%times(it), in_teams=1)

                  end do

!$omp end teams
               #:endif

               #:if defined("OMB_OMP_TEAMS_PARALLEL")
                  type is (option_kernel_teams_parallel_manual_t)
!$omp teams private(it,i,istart,iend) &
!$omp&  num_teams(1) thread_limit(options%num_threads)

!$omp parallel private(it,i,istart,iend)
                  call manual_split(n, istart, iend)

                  do it = 1, options%it

                     @:START_TIMING()

                     do i = istart, iend
                        a(i) = b(i) + scale*c(i)
                     end do

                     @:STOP_TIMING(results%times(it))

                  end do
!$omp end parallel

!$omp end teams

                  type is (option_kernel_teams_parallel_do_t)
!$omp teams private(it,i,team) &
!$omp&  num_teams(1) thread_limit(options%num_threads)

                  team = omp_get_team_num()

                  do it = 1, options%it

                     @:START_TIMING(in_teams=1)

!$omp parallel do schedule(runtime)
                     do i = 1, n
                        a(i) = b(i) + scale*c(i)
                     end do
!$omp end parallel do

                     @:STOP_TIMING(results%times(it), in_teams=1)

                  end do

!$omp end teams

                  type is (option_kernel_teams_parallel_loop_t)
!$omp teams private(it,i,team) &
!$omp&  num_teams(1) thread_limit(options%num_threads)

                  team = omp_get_team_num()

                  do it = 1, options%it

                     @:START_TIMING(in_teams=1)

!$omp parallel
!$omp loop
                     do i = 1, n
                        a(i) = b(i) + scale*c(i)
                     end do
!$omp end loop
!$omp end parallel

                     @:STOP_TIMING(results%times(it), in_teams=1)

                  end do

!$omp end teams
               #:endif
            #:endif

         class default

!$omp parallel private(it,i,istart,iend)
            call manual_split(n, istart, iend)

            do it = 1, options%it

               select type (kernel => options%kernel)

                  @:TYPE_IS(option_kernel_manual_t)
                  do i = istart, iend
                     a(i) = b(i) + scale*c(i)
                  end do

                  @:TYPE_IS(option_kernel_do_t)
!$omp do schedule(runtime)
                  do i = 1, n
                     a(i) = b(i) + scale*c(i)
                  end do
!$omp end do

                  @:TYPE_IS(option_kernel_do_simd_t)
!$omp do simd schedule(runtime)
                  do i = 1, n
                     a(i) = b(i) + scale*c(i)
                  end do
!$omp end do simd

                  @:TYPE_IS(option_kernel_workshare_t)
!$omp workshare
                  a(1:n) = b(1:n) + scale*c(1:n)
!$omp end workshare

                  #:if defined("OMB_OMP_TASKLOOP")
                     @:TYPE_IS(option_kernel_taskloop_t)
!$omp single
!$omp taskloop num_tasks(kernel%num_tasks)
                     do i = 1, n
                        a(i) = b(i) + scale*c(i)
                     end do
!$omp end taskloop
!$omp end single

                     @:TYPE_IS(option_kernel_taskloop_simd_t)
!$omp single
!$omp taskloop simd num_tasks(kernel%num_tasks)
                     do i = 1, n
                        a(i) = b(i) + scale*c(i)
                     end do
!$omp end taskloop simd
!$omp end single
                  #:endif

                  @:TYPE_IS(option_kernel_loop_t)
!$omp loop
                  do i = 1, n
                     a(i) = b(i) + scale*c(i)
                  end do
!$omp end loop

               class default

                  stop UNKNOWN_METHOD_STOP

               end select

               @:STOP_TIMING(results%times(it))

            end do

!$omp end parallel

         end select

         call results%update(3, n, 2, storage_size(1.0_${real}$))

         if (options%test) then
            write (*, test_fmt) sum(a(1:n)) - n*(1.5_${real}$+scale*2.5_${real}$)
         end if

         @:ARRAY_DEALLOC(a, b, c)

      end subroutine

      subroutine bench_tetradd_${real}$ (n, options, results)
         integer(${OMB_INT_KIND}$), intent(in) :: n
         type(options_t), intent(in):: options
         type(results_t), intent(inout) :: results

         integer(${OMB_INT_KIND}$) :: i, istart, iend
         integer :: it, team
         type(timing_t) :: timing

         @:ARRAY_DEFINE(${real}$, n + options%offset, a, b, c, d)

!$omp parallel
         call array_allocate(n, a, options)
         call array_allocate(n, b, options)
         call array_allocate(n, c, options)
         call array_allocate(n, d, options)
         call init_array(n, a, 0.5_${real}$, options)
         call init_array(n, b, 1.5_${real}$, options)
         call init_array(n, c, 2.5_${real}$, options)
         call init_array(n, d, 3.5_${real}$, options)
!$omp end parallel

         if (options%test) then
            write (*, test_fmt, advance="no") sum(a(1:n)) - n*0.5_${real}$
         end if

         select type (kernel => options%kernel)

         type is (option_kernel_serial_t)

            do it = 1, options%it
               call timing%start()
               do i = 1, n
                  a(i) = b(i) + c(i)*d(i)
               end do
               call timing%stop(results%times(it))
            end do

            #:if defined("OMB_OMP_TEAMS")
               type is (option_kernel_teams_manual_t)
!$omp teams private(it,i,team,istart,iend) &
!$omp&  num_teams(options%num_threads) thread_limit(1)
               call manual_split(n, istart, iend, in_teams=.true.)

               team = omp_get_team_num()

               do it = 1, options%it

                  @:START_TIMING(in_teams=1)

                  do i = istart, iend
                     a(i) = b(i) + c(i)*d(i)
                  end do

                  @:STOP_TIMING(results%times(it), in_teams=1)

               end do

!$omp end teams

               #:if defined("OMB_OMP_TEAMS_DISTRIBUTE")
                  type is (option_kernel_teams_distribute_t)
!$omp teams private(it,i,team) &
!$omp&  num_teams(options%num_threads) thread_limit(1)

                  team = omp_get_team_num()

                  do it = 1, options%it

                     @:START_TIMING(in_teams=1)

!$omp distribute dist_schedule(static)
                     do i = 1, n
                        a(i) = b(i) + c(i)*d(i)
                     end do
!$omp end distribute

                     @:STOP_TIMING(results%times(it), in_teams=1)

                  end do

!$omp end teams

                  type is (option_kernel_teams_distribute_do_t)
!$omp teams private(it,i,team) &
!$omp&  num_teams(options%num_threads) thread_limit(1)

                  team = omp_get_team_num()

                  do it = 1, options%it

                     @:START_TIMING(in_teams=1)

!$omp distribute parallel do dist_schedule(static)
                     do i = 1, n
                        a(i) = b(i) + c(i)*d(i)
                     end do
!$omp end distribute parallel do

                     @:STOP_TIMING(results%times(it), in_teams=1)

                  end do

!$omp end teams
               #:endif

               #:if defined("OMB_OMP_TEAMS_PARALLEL")
                  type is (option_kernel_teams_parallel_manual_t)
!$omp teams private(it,i,istart,iend) &
!$omp&  num_teams(1) thread_limit(options%num_threads)

!$omp parallel private(it,i,istart,iend)
                  call manual_split(n, istart, iend)

                  do it = 1, options%it

                     @:START_TIMING()

                     do i = istart, iend
                        a(i) = b(i) + c(i)*d(i)
                     end do

                     @:STOP_TIMING(results%times(it))

                  end do
!$omp end parallel

!$omp end teams

                  type is (option_kernel_teams_parallel_do_t)
!$omp teams private(it,i,team) &
!$omp&  num_teams(1) thread_limit(options%num_threads)

                  team = omp_get_team_num()

                  do it = 1, options%it

                     @:START_TIMING(in_teams=1)

!$omp parallel do schedule(runtime)
                     do i = 1, n
                        a(i) = b(i) + c(i)*d(i)
                     end do
!$omp end parallel do

                     @:STOP_TIMING(results%times(it), in_teams=1)

                  end do

!$omp end teams

                  type is (option_kernel_teams_parallel_loop_t)
!$omp teams private(it,i,team) &
!$omp&  num_teams(1) thread_limit(options%num_threads)

                  team = omp_get_team_num()

                  do it = 1, options%it

                     @:START_TIMING(in_teams=1)

!$omp parallel
!$omp loop
                     do i = 1, n
                        a(i) = b(i) + c(i)*d(i)
                     end do
!$omp end loop
!$omp end parallel

                     @:STOP_TIMING(results%times(it), in_teams=1)

                  end do

!$omp end teams
               #:endif
            #:endif

         class default

!$omp parallel private(it,i,istart,iend)
            call manual_split(n, istart, iend)

            do it = 1, options%it

               select type (kernel => options%kernel)

                  @:TYPE_IS(option_kernel_manual_t)
                  do i = istart, iend
                     a(i) = b(i) + c(i)*d(i)
                  end do

                  @:TYPE_IS(option_kernel_do_t)
!$omp do schedule(runtime)
                  do i = 1, n
                     a(i) = b(i) + c(i)*d(i)
                  end do
!$omp end do

                  @:TYPE_IS(option_kernel_do_simd_t)
!$omp do simd schedule(runtime)
                  do i = 1, n
                     a(i) = b(i) + c(i)*d(i)
                  end do
!$omp end do simd

                  @:TYPE_IS(option_kernel_workshare_t)
!$omp workshare
                  a(1:n) = b(1:n) + c(1:n)*d(1:n)
!$omp end workshare

                  #:if defined("OMB_OMP_TASKLOOP")
                     @:TYPE_IS(option_kernel_taskloop_t)
!$omp single
!$omp taskloop num_tasks(kernel%num_tasks)
                     do i = 1, n
                        a(i) = b(i) + c(i)*d(i)
                     end do
!$omp end taskloop
!$omp end single

                     @:TYPE_IS(option_kernel_taskloop_simd_t)
!$omp single
!$omp taskloop simd num_tasks(kernel%num_tasks)
                     do i = 1, n
                        a(i) = b(i) + c(i)*d(i)
                     end do
!$omp end taskloop simd
!$omp end single
                  #:endif

                  @:TYPE_IS(option_kernel_loop_t)
!$omp loop
                  do i = 1, n
                     a(i) = b(i) + c(i)*d(i)
                  end do
!$omp end loop

               class default

                  stop UNKNOWN_METHOD_STOP

               end select

               @:STOP_TIMING(results%times(it))

            end do

!$omp end parallel

         end select

         call results%update(4, n, 2, storage_size(1.0_${real}$))

         if (options%test) then
            write (*, test_fmt) sum(a(1:n)) - n*(1.5_${real}$+2.5_${real}$*3.5_${real}$)
         end if

         @:ARRAY_DEALLOC(a, b, c, d)

      end subroutine

      subroutine bench_pentadd_${real}$ (n, options, results)
         integer(${OMB_INT_KIND}$), intent(in) :: n
         type(options_t), intent(in):: options
         type(results_t), intent(inout) :: results

         integer(${OMB_INT_KIND}$) :: i, istart, iend
         integer :: it, team
         type(timing_t) :: timing

         @:ARRAY_DEFINE(${real}$, n + options%offset, a, b, c, d, e)

!$omp parallel
         call array_allocate(n, a, options)
         call array_allocate(n, b, options)
         call array_allocate(n, c, options)
         call array_allocate(n, d, options)
         call array_allocate(n, e, options)
         call init_array(n, a, 0.5_${real}$, options)
         call init_array(n, b, 1.5_${real}$, options)
         call init_array(n, c, 2.5_${real}$, options)
         call init_array(n, d, 3.5_${real}$, options)
         call init_array(n, e, 3._${real}$, options)
!$omp end parallel

         if (options%test) then
            write (*, test_fmt, advance="no") sum(a(1:n)) - n*0.5_${real}$
         end if

         select type (kernel => options%kernel)

         type is (option_kernel_serial_t)

            do it = 1, options%it
               call timing%start()
               do i = 1, n
                  a(i) = b(i)*c(i) + d(i)*e(i)
               end do
               call timing%stop(results%times(it))
            end do

            #:if defined("OMB_OMP_TEAMS")
               type is (option_kernel_teams_manual_t)
!$omp teams private(it,i,team,istart,iend) &
!$omp&  num_teams(options%num_threads) thread_limit(1)
               call manual_split(n, istart, iend, in_teams=.true.)

               team = omp_get_team_num()

               do it = 1, options%it

                  @:START_TIMING(in_teams=1)

                  do i = istart, iend
                     a(i) = b(i)*c(i) + d(i)*e(i)
                  end do

                  @:STOP_TIMING(results%times(it), in_teams=1)

               end do

!$omp end teams

               #:if defined("OMB_OMP_TEAMS_DISTRIBUTE")
                  type is (option_kernel_teams_distribute_t)
!$omp teams private(it,i,team) &
!$omp&  num_teams(options%num_threads) thread_limit(1)

                  team = omp_get_team_num()

                  do it = 1, options%it

                     @:START_TIMING(in_teams=1)

!$omp distribute dist_schedule(static)
                     do i = 1, n
                        a(i) = b(i)*c(i) + d(i)*e(i)
                     end do
!$omp end distribute

                     @:STOP_TIMING(results%times(it), in_teams=1)

                  end do

!$omp end teams

                  type is (option_kernel_teams_distribute_do_t)
!$omp teams private(it,i,team) &
!$omp&  num_teams(options%num_threads) thread_limit(1)

                  team = omp_get_team_num()

                  do it = 1, options%it

                     @:START_TIMING(in_teams=1)

!$omp distribute parallel do dist_schedule(static)
                     do i = 1, n
                        a(i) = b(i)*c(i) + d(i)*e(i)
                     end do
!$omp end distribute parallel do

                     @:STOP_TIMING(results%times(it), in_teams=1)

                  end do

!$omp end teams
               #:endif

               #:if defined("OMB_OMP_TEAMS_PARALLEL")
                  type is (option_kernel_teams_parallel_manual_t)
!$omp teams private(it,i,istart,iend) &
!$omp&  num_teams(1) thread_limit(options%num_threads)

!$omp parallel private(it,i,istart,iend)
                  call manual_split(n, istart, iend)

                  do it = 1, options%it

                     @:START_TIMING()

                     do i = istart, iend
                        a(i) = b(i)*c(i) + d(i)*e(i)
                     end do

                     @:STOP_TIMING(results%times(it))

                  end do
!$omp end parallel

!$omp end teams

                  type is (option_kernel_teams_parallel_do_t)
!$omp teams private(it,i,team) &
!$omp&  num_teams(1) thread_limit(options%num_threads)

                  team = omp_get_team_num()

                  do it = 1, options%it

                     @:START_TIMING(in_teams=1)

!$omp parallel do schedule(runtime)
                     do i = 1, n
                        a(i) = b(i)*c(i) + d(i)*e(i)
                     end do
!$omp end parallel do

                     @:STOP_TIMING(results%times(it), in_teams=1)

                  end do

!$omp end teams

                  type is (option_kernel_teams_parallel_loop_t)
!$omp teams private(it,i,team) &
!$omp&  num_teams(1) thread_limit(options%num_threads)

                  team = omp_get_team_num()

                  do it = 1, options%it

                     @:START_TIMING(in_teams=1)

!$omp parallel
!$omp loop
                     do i = 1, n
                        a(i) = b(i)*c(i) + d(i)*e(i)
                     end do
!$omp end loop
!$omp end parallel

                     @:STOP_TIMING(results%times(it), in_teams=1)

                  end do

!$omp end teams
               #:endif
            #:endif

         class default

!$omp parallel private(it,i,istart,iend)
            call manual_split(n, istart, iend)

            do it = 1, options%it

               select type (kernel => options%kernel)

                  @:TYPE_IS(option_kernel_manual_t)
                  do i = istart, iend
                     a(i) = b(i)*c(i) + d(i)*e(i)
                  end do

                  @:TYPE_IS(option_kernel_do_t)
!$omp do schedule(runtime)
                  do i = 1, n
                     a(i) = b(i)*c(i) + d(i)*e(i)
                  end do
!$omp end do

                  @:TYPE_IS(option_kernel_do_simd_t)
!$omp do simd schedule(runtime)
                  do i = 1, n
                     a(i) = b(i)*c(i) + d(i)*e(i)
                  end do
!$omp end do simd

                  @:TYPE_IS(option_kernel_workshare_t)
!$omp workshare
                  a(1:n) = b(1:n)*c(1:n) + d(1:n)*e(1:n)
!$omp end workshare

                  #:if defined("OMB_OMP_TASKLOOP")
                     @:TYPE_IS(option_kernel_taskloop_t)
!$omp single
!$omp taskloop num_tasks(kernel%num_tasks)
                     do i = 1, n
                        a(i) = b(i)*c(i) + d(i)*e(i)
                     end do
!$omp end taskloop
!$omp end single

                     @:TYPE_IS(option_kernel_taskloop_simd_t)
!$omp single
!$omp taskloop simd num_tasks(kernel%num_tasks)
                     do i = 1, n
                        a(i) = b(i)*c(i) + d(i)*e(i)
                     end do
!$omp end taskloop simd
!$omp end single
                  #:endif

                  @:TYPE_IS(option_kernel_loop_t)
!$omp loop
                  do i = 1, n
                     a(i) = b(i)*c(i) + d(i)*e(i)
                  end do
!$omp end loop

               class default

                  stop UNKNOWN_METHOD_STOP

               end select

               @:STOP_TIMING(results%times(it))

            end do

!$omp end parallel

         end select

         call results%update(5, n, 3, storage_size(1.0_${real}$))

         if (options%test) then
            write (*, test_fmt) sum(a(1:n)) - n*(1.5_${real}$*2.5_${real}$+3*3.5_${real}$)
         end if

         @:ARRAY_DEALLOC(a, b, c, d, e)

      end subroutine

      subroutine bench_axpy_${real}$ (n, options, results)
         integer(${OMB_INT_KIND}$), intent(in) :: n
         type(options_t), intent(in):: options
         type(results_t), intent(inout) :: results

         integer(${OMB_INT_KIND}$) :: i, istart, iend
         integer :: it, team
         type(timing_t) :: timing

         real(${real}$) :: scale
         @:ARRAY_DEFINE(${real}$, n + options%offset, a, b)

         scale = 2._${real}$

!$omp parallel
         call array_allocate(n, a, options)
         call array_allocate(n, b, options)
         call init_array(n, a, 0.5_${real}$, options)
         call init_array(n, b, 1.5_${real}$, options)
!$omp end parallel

         if (options%test) then
            write (*, test_fmt, advance="no") sum(a(1:n)) - n*0.5_${real}$
         end if

         select type (kernel => options%kernel)

         type is (option_kernel_serial_t)

            do it = 1, options%it
               call timing%start()
               do i = 1, n
                  a(i) = a(i) + scale*b(i)
               end do
               call timing%stop(results%times(it))
            end do

            #:if defined("OMB_OMP_TEAMS")
               type is (option_kernel_teams_manual_t)
!$omp teams private(it,i,team,istart,iend) &
!$omp&  num_teams(options%num_threads) thread_limit(1)
               call manual_split(n, istart, iend, in_teams=.true.)

               team = omp_get_team_num()

               do it = 1, options%it

                  @:START_TIMING(in_teams=1)

                  do i = istart, iend
                     a(i) = a(i) + scale*b(i)
                  end do

                  @:STOP_TIMING(results%times(it), in_teams=1)

               end do

!$omp end teams

               #:if defined("OMB_OMP_TEAMS_DISTRIBUTE")
                  type is (option_kernel_teams_distribute_t)
!$omp teams private(it,i,team) &
!$omp&  num_teams(options%num_threads) thread_limit(1)

                  team = omp_get_team_num()

                  do it = 1, options%it

                     @:START_TIMING(in_teams=1)

!$omp distribute dist_schedule(static)
                     do i = 1, n
                        a(i) = a(i) + scale*b(i)
                     end do
!$omp end distribute

                     @:STOP_TIMING(results%times(it), in_teams=1)

                  end do

!$omp end teams

                  type is (option_kernel_teams_distribute_do_t)
!$omp teams private(it,i,team) &
!$omp&  num_teams(options%num_threads) thread_limit(1)

                  team = omp_get_team_num()

                  do it = 1, options%it

                     @:START_TIMING(in_teams=1)

!$omp distribute parallel do dist_schedule(static)
                     do i = 1, n
                        a(i) = a(i) + scale*b(i)
                     end do
!$omp end distribute parallel do

                     @:STOP_TIMING(results%times(it), in_teams=1)

                  end do

!$omp end teams
               #:endif

               #:if defined("OMB_OMP_TEAMS_PARALLEL")
                  type is (option_kernel_teams_parallel_manual_t)
!$omp teams private(it,i,istart,iend) &
!$omp&  num_teams(1) thread_limit(options%num_threads)

!$omp parallel private(it,i,istart,iend)
                  call manual_split(n, istart, iend)

                  do it = 1, options%it

                     @:START_TIMING()

                     do i = istart, iend
                        a(i) = a(i) + scale*b(i)
                     end do

                     @:STOP_TIMING(results%times(it))

                  end do
!$omp end parallel

!$omp end teams

                  type is (option_kernel_teams_parallel_do_t)
!$omp teams private(it,i,team) &
!$omp&  num_teams(1) thread_limit(options%num_threads)

                  team = omp_get_team_num()

                  do it = 1, options%it

                     @:START_TIMING(in_teams=1)

!$omp parallel do schedule(runtime)
                     do i = 1, n
                        a(i) = a(i) + scale*b(i)
                     end do
!$omp end parallel do

                     @:STOP_TIMING(results%times(it), in_teams=1)

                  end do

!$omp end teams

                  type is (option_kernel_teams_parallel_loop_t)
!$omp teams private(it,i,team) &
!$omp&  num_teams(1) thread_limit(options%num_threads)

                  team = omp_get_team_num()

                  do it = 1, options%it

                     @:START_TIMING(in_teams=1)

!$omp parallel
!$omp loop
                     do i = 1, n
                        a(i) = a(i) + scale*b(i)
                     end do
!$omp end loop
!$omp end parallel

                     @:STOP_TIMING(results%times(it), in_teams=1)

                  end do

!$omp end teams
               #:endif
            #:endif

         class default

!$omp parallel private(it,i,istart,iend)
            call manual_split(n, istart, iend)

            do it = 1, options%it

               select type (kernel => options%kernel)

                  @:TYPE_IS(option_kernel_manual_t)
                  do i = istart, iend
                     a(i) = a(i) + scale*b(i)
                  end do

                  @:TYPE_IS(option_kernel_do_t)
!$omp do schedule(runtime)
                  do i = 1, n
                     a(i) = a(i) + scale*b(i)
                  end do
!$omp end do

                  @:TYPE_IS(option_kernel_do_simd_t)
!$omp do simd schedule(runtime)
                  do i = 1, n
                     a(i) = a(i) + scale*b(i)
                  end do
!$omp end do simd

                  @:TYPE_IS(option_kernel_workshare_t)
!$omp workshare
                  a(1:n) = a(1:n) + scale*b(1:n)
!$omp end workshare

                  #:if defined("OMB_OMP_TASKLOOP")
                     @:TYPE_IS(option_kernel_taskloop_t)
!$omp single
!$omp taskloop num_tasks(kernel%num_tasks)
                     do i = 1, n
                        a(i) = a(i) + scale*b(i)
                     end do
!$omp end taskloop
!$omp end single

                     @:TYPE_IS(option_kernel_taskloop_simd_t)
!$omp single
!$omp taskloop simd num_tasks(kernel%num_tasks)
                     do i = 1, n
                        a(i) = a(i) + scale*b(i)
                     end do
!$omp end taskloop simd
!$omp end single
                  #:endif

                  @:TYPE_IS(option_kernel_loop_t)
!$omp loop
                  do i = 1, n
                     a(i) = a(i) + scale*b(i)
                  end do
!$omp end loop

               class default

                  stop UNKNOWN_METHOD_STOP

               end select

               @:STOP_TIMING(results%times(it))

            end do

!$omp end parallel

         end select

         call results%update(2, n, 2, storage_size(1.0_${real}$))

         if (options%test) then
            write (*, test_fmt) sum(a(1:n)) - n*(0.5_${real}$+scale*1.5_${real}$)
         end if

         @:ARRAY_DEALLOC(a, b)

      end subroutine

      subroutine bench_false_sharing_triadd_${real}$ (n, options, results)
         use omp_lib, only: omp_get_thread_num
         integer(${OMB_INT_KIND}$), intent(in) :: n
         type(options_t), intent(in):: options
         type(results_t), intent(inout) :: results

         integer(${OMB_INT_KIND}$) :: i
         integer :: id, it, team, teams
         type(timing_t) :: timing

         real(${real}$) :: scale

         #:if ARRAY_IS_STACK
            real(${real}$), dimension(options%num_threads, n + options%offset) :: a, b, c
         #:else
            real(${real}$), dimension(:, :), ${OMB_ALLOC_TYPE}$ &
               ${OMB_ARRAY_ATTRIBUTES}$ :: a, b, c
         #:endif

         scale = 2._${real}$

         #:if ARRAY_IS_POINTER
            nullify (a, b, c)
         #:endif

         #:if not ARRAY_IS_STACK
            allocate (a(options%num_threads, n + options%offset))
            allocate (b(options%num_threads, n + options%offset))
            allocate (c(options%num_threads, n + options%offset))
         #:endif

!$omp parallel
         ! Direct call to omit interface constructs which has different shape
         call init_array_${real}$ (options%num_threads*n, a, 0.5_${real}$, options)
         call init_array_${real}$ (options%num_threads*n, b, 1.5_${real}$, options)
         call init_array_${real}$ (options%num_threads*n, c, 2.5_${real}$, options)
!$omp end parallel

         if (options%test) then
            write (*, test_fmt, advance="no") sum(a(:, 1:n)) - options%num_threads*n*0.5_${real}$
         end if

         select type (kernel => options%kernel)

            #:if defined("OMB_OMP_TEAMS")
               type is (option_kernel_teams_manual_t)
!$omp teams private(it,i,team,id) &
!$omp&  num_teams(options%num_threads) thread_limit(1)

               ! This kernel uses each teams main thread (only 1 thread per team)
               team = omp_get_team_num()
               id = team + 1

               do it = 1, options%it

                  @:START_TIMING(in_teams=1)

                  do i = 1, n
                     a(id, i) = b(id, i) + scale*c(id, i)
                  end do

                  @:STOP_TIMING(results%times(it), in_teams=1)

               end do

!$omp end teams

               #:if defined("OMB_OMP_TEAMS_DISTRIBUTE")
                  type is (option_kernel_teams_distribute_t)
!$omp teams private(it,i,team,teams,id) &
!$omp&  num_teams(options%num_threads) thread_limit(1)

                  ! This kernel uses each teams main thread (only 1 thread per team)
                  team = omp_get_team_num()
                  teams = omp_get_num_teams()

                  do it = 1, options%it

                     @:START_TIMING(in_teams=1)

!$omp distribute dist_schedule(static,1) private(i)
                     do id = 1, teams
                        do i = 1, n
                           a(id, i) = b(id, i) + scale*c(id, i)
                        end do
                     end do
!$omp end distribute

                     @:STOP_TIMING(results%times(it), in_teams=1)

                  end do

!$omp end teams

                  type is (option_kernel_teams_distribute_do_t)
!$omp teams private(it,i,team,teams,id) &
!$omp&  num_teams(options%num_threads) thread_limit(1)

                  ! This kernel uses each teams main thread (only 1 thread per team)
                  team = omp_get_team_num()
                  teams = omp_get_num_teams()

                  do it = 1, options%it

                     @:START_TIMING(in_teams=1)

!$omp distribute parallel do dist_schedule(static,1) private(i)
                     do id = 1, teams
                        do i = 1, n
                           a(id, i) = b(id, i) + scale*c(id, i)
                        end do
                     end do
!$omp end distribute parallel do

                     @:STOP_TIMING(results%times(it), in_teams=1)

                  end do

!$omp end teams
               #:endif

               #:if defined("OMB_OMP_TEAMS_PARALLEL")
                  type is (option_kernel_teams_parallel_do_t)
!$omp teams private(it,i,team,id) &
!$omp&  num_teams(1) thread_limit(options%num_threads)

                  ! This kernel uses one team, and then distributes
                  ! threads in the team in the parallel
                  team = omp_get_team_num()

                  do it = 1, options%it

                     @:START_TIMING(in_teams=1)

!$omp parallel private(i,id)
                     id = omp_get_thread_num() + 1
                     do i = 1, n
                        a(id, i) = b(id, i) + scale*c(id, i)
                     end do
!$omp end parallel

                     @:STOP_TIMING(results%times(it), in_teams=1)

                  end do

!$omp end teams
               #:endif
            #:endif

         class default

!$omp parallel private(it,i,id)

            ! Get local thread-id
            id = omp_get_thread_num() + 1

            do it = 1, options%it

               select type (kernel => options%kernel)

                  @:TYPE_IS(option_kernel_do_t)

                  ! To traverse everything, we don't need an OMP loop
                  ! Each thread accesses its own space.
                  do i = 1, n
                     a(id, i) = b(id, i) + scale*c(id, i)
                  end do

                  @:TYPE_IS(option_kernel_workshare_t)

                  a(id, :) = b(id, :) + scale*c(id, :)

               class default

                  stop UNKNOWN_METHOD_STOP

               end select

               @:STOP_TIMING(results%times(it))

            end do

!$omp end parallel

         end select

         call results%update(3, options%num_threads*n, 2, storage_size(1.0_${real}$))

         if (options%test) then
            write (*, test_fmt) sum(a(:, 1:n)) - options%num_threads*n*(1.5_${real}$+scale*2.5_${real}$)
         end if

         @:ARRAY_DEALLOC(a, b, c)

      end subroutine

      subroutine bench_false_sharing_tetradd_${real}$ (n, options, results)
         use omp_lib, only: omp_get_thread_num
         integer(${OMB_INT_KIND}$), intent(in) :: n
         type(options_t), intent(in):: options
         type(results_t), intent(inout) :: results

         integer(${OMB_INT_KIND}$) :: i
         integer :: id, it, team, teams
         type(timing_t) :: timing

         #:if ARRAY_IS_STACK
            real(${real}$), dimension(options%num_threads, n + options%offset) :: a, b, c, d
         #:else
            real(${real}$), dimension(:, :), ${OMB_ALLOC_TYPE}$ &
               ${OMB_ARRAY_ATTRIBUTES}$ :: a, b, c, d
         #:endif

         #:if ARRAY_IS_POINTER
            nullify (a, b, c, d)
         #:endif

         #:if not ARRAY_IS_STACK
            allocate (a(options%num_threads, n + options%offset))
            allocate (b(options%num_threads, n + options%offset))
            allocate (c(options%num_threads, n + options%offset))
            allocate (d(options%num_threads, n + options%offset))
         #:endif

!$omp parallel
         ! Direct call to omit interface constructs which has different shape
         call init_array_${real}$ (options%num_threads*n, a, 0.5_${real}$, options)
         call init_array_${real}$ (options%num_threads*n, b, 1.5_${real}$, options)
         call init_array_${real}$ (options%num_threads*n, c, 2.5_${real}$, options)
         call init_array_${real}$ (options%num_threads*n, d, 3.5_${real}$, options)
!$omp end parallel

         if (options%test) then
            write (*, test_fmt, advance="no") sum(a(:, 1:n)) - options%num_threads*n*0.5_${real}$
         end if

         select type (kernel => options%kernel)

            #:if defined("OMB_OMP_TEAMS_DISTRIBUTE")
               type is (option_kernel_teams_manual_t)
!$omp teams private(it,i,team,id) &
!$omp&  num_teams(options%num_threads) thread_limit(1)

               ! This kernel uses each teams main thread (only 1 thread per team)
               team = omp_get_team_num()
               id = team + 1

               do it = 1, options%it

                  @:START_TIMING(in_teams=1)

                  do i = 1, n
                     a(id, i) = b(id, i) + c(id, i)*d(id, i)
                  end do

                  @:STOP_TIMING(results%times(it), in_teams=1)

               end do

!$omp end teams

               #:if defined("OMB_OMP_TEAMS_DISTRIBUTE")
                  type is (option_kernel_teams_distribute_t)
!$omp teams private(it,i,team,teams,id) &
!$omp&  num_teams(options%num_threads) thread_limit(1)

                  ! This kernel uses each teams main thread (only 1 thread per team)
                  team = omp_get_team_num()
                  teams = omp_get_num_teams()

                  do it = 1, options%it

                     @:START_TIMING(in_teams=1)

!$omp distribute dist_schedule(static) private(i)
                     do id = 1, teams
                        do i = 1, n
                           a(id, i) = b(id, i) + c(id, i)*d(id, i)
                        end do
                     end do
!$omp end distribute

                     @:STOP_TIMING(results%times(it), in_teams=1)

                  end do

!$omp end teams

                  type is (option_kernel_teams_distribute_do_t)
!$omp teams private(it,i,team,teams,id) &
!$omp&  num_teams(options%num_threads) thread_limit(1)

                  ! This kernel uses each teams main thread (only 1 thread per team)
                  team = omp_get_team_num()
                  teams = omp_get_num_teams()

                  do it = 1, options%it

                     @:START_TIMING(in_teams=1)

!$omp distribute parallel do dist_schedule(static,1) private(i)
                     do id = 1, teams
                        do i = 1, n
                           a(id, i) = b(id, i) + c(id, i)*d(id, i)
                        end do
                     end do
!$omp end distribute parallel do

                     @:STOP_TIMING(results%times(it), in_teams=1)

                  end do

!$omp end teams
               #:endif

               #:if defined("OMB_OMP_TEAMS_PARALLEL")
                  type is (option_kernel_teams_parallel_do_t)
!$omp teams private(it,i,team,id) &
!$omp&  num_teams(1) thread_limit(options%num_threads)

                  ! This kernel uses one team, and then distributes
                  ! threads in the team in the parallel
                  team = omp_get_team_num()

                  do it = 1, options%it

                     @:START_TIMING(in_teams=1)

!$omp parallel private(i,id)
                     id = omp_get_thread_num() + 1
                     do i = 1, n
                        a(id, i) = b(id, i) + c(id, i)*d(id, i)
                     end do
!$omp end parallel

                     @:STOP_TIMING(results%times(it), in_teams=1)

                  end do

!$omp end teams
               #:endif
            #:endif

         class default

!$omp parallel private(it,i,id)

            ! Get local thread-id
            id = omp_get_thread_num() + 1

            do it = 1, options%it

               select type (kernel => options%kernel)

                  @:TYPE_IS(option_kernel_do_t)

                  ! To traverse everything, we don't need an OMP loop
                  ! Each thread accesses its own space.
                  do i = 1, n
                     a(id, i) = b(id, i) + c(id, i)*d(id, i)
                  end do

                  @:TYPE_IS(option_kernel_workshare_t)

                  a(id, :) = b(id, :) + c(id, :)*d(id, :)

               class default

                  stop UNKNOWN_METHOD_STOP

               end select

               @:STOP_TIMING(results%times(it))

            end do

!$omp end parallel

         end select

         call results%update(4, options%num_threads*n, 2, storage_size(1.0_${real}$))

         if (options%test) then
            write (*, test_fmt) sum(a(:, 1:n)) - options%num_threads*n*(1.5_${real}$+2.5_${real}$*3.5_${real}$)
         end if

         @:ARRAY_DEALLOC(a, b, c, d)

      end subroutine

   #:endfor

   subroutine manual_split(n, istart, iend, in_teams)
      integer(${OMB_INT_KIND}$), intent(in) :: n
      integer(${OMB_INT_KIND}$), intent(out) :: istart, iend
      logical, intent(in), optional :: in_teams

      logical :: lin_teams
      integer :: nt, id
      integer(${OMB_INT_KIND}$) :: split

      lin_teams = .false.
      if (present(in_teams)) lin_teams = in_teams
      if (lin_teams) then
         nt = omp_get_num_teams()
         id = omp_get_team_num()
      else
         nt = omp_get_num_threads()
         id = omp_get_thread_num()
      end if

      ! Now calculate what we will loop
      split = n/nt

      istart = split*id + 1
      iend = split*(id + 1)

      if (nt == id + 1) then
         ! Ensure the last one gets the correct number of iterations
         ! In case it does not match number of threads
         iend = iend + mod(n, nt)
      end if

   end subroutine

end module benchmarks_m
