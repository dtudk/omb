#:include "common.fypp"

program main

   ! Benchmark tests for OpenMP threads.
   ! This small utility program allows one to
   ! benchmark how read/write/read+write access
   ! in done with OpenMP.
   #:if defined('OMB_MPI')
      use mpi_f08
   #:endif
   use omp_lib
   use iso_fortran_env, only: OUTPUT_UNIT, ERROR_UNIT
   #:if "real16" in REALS
      use iso_fortran_env, only: real16
   #:endif
   use iso_fortran_env, only: real32, real64
   #:if "real128" in REALS
      use iso_fortran_env, only: real128
   #:endif
   use iso_fortran_env, only: int32, int64

   ! This is a pure fortran code, but should be able
   ! to give same results for C/C++.
   ! Generally, the OpenMP implementation is a bit
   ! behind for fortran compilers.
   use timing_m, only: timing_initialize
   use options_m
   use results_m, only: results_t
   use info_omp_m, only: info_env_t
   use benchmarks_m ! ALL

   implicit none

   character(len=*), parameter :: debug_fmt_a = "(a,t35,':',256(tr1,a))"
   character(len=*), parameter :: debug_fmt_i = "(a,t35,':',256(tr1,i0))"
   character(len=*), parameter :: debug_fmt_l = "(a,t35,':',256(tr1,l0))"
   character(len=*), parameter :: debug_fmt_e = "(a,t35,':',256(tr1,en0.10))"

   ! Maximum byte size of *any* data-type.
   ! This is the aligned data size of the final number of elements.
   ! We don't do this based on what is available for the compiler.
   ! That would mean that you would get different array sizes
   ! depending on what the compiler supports.
   integer, parameter :: MIN_ELEM_BYTES = 2
   integer, parameter :: MAX_ELEM_BYTES = 16

   ! We need to at least have each array size on the order of 4 times the cache size
   ! to move the entire array out and ensure no caching is there...
   ! So, lets just take 4GB for safety.
   real(real64), parameter :: bytes2MB = 1._real64/1024**2
   real(real64), parameter :: DEFAULT_BYTES = 4._real64*1024**3

   integer, parameter :: DTYPE_REAL16 = 1
   integer, parameter :: DTYPE_REAL32 = 2
   integer, parameter :: DTYPE_REAL64 = 3
   integer, parameter :: DTYPE_REAL128 = 4
   integer :: dtype = DTYPE_REAL64

   ! Method definitions
   real(real64) :: bytes = DEFAULT_BYTES
   integer :: method
   character(len=64) :: method_str
   integer :: num_tasks = 0
   procedure(benchmark_interface), pointer :: benchmark => null()

   type(options_t) :: options
   type(results_t) :: results

   type(info_env_t) :: info_env

   logical :: option_set_it = .false.

   integer :: rank_mpi = 0
   #:if defined('OMB_MPI')
      integer :: ierr_mpi
      integer :: size_mpi
   #:endif

   #:if defined('OMB_MPI')
      call MPI_Init(ierr_mpi)

      ! Get rank and size
      call MPI_Comm_rank(MPI_COMM_WORLD, rank_mpi)
      call MPI_Comm_size(MPI_COMM_WORLD, size_mpi)
   #:endif

   ! Initialize the timing
   call timing_initialize()

   ! Defining the defaults
   method = METHOD_TRIADD
   results%info%narrays = 3
   results%info%stores = 1
   results%info%reads = 2
   results%info%flop = 2

   ! Determine number of threads in this run...
!$omp parallel shared(options)
!$omp single
   options%num_threads = omp_get_num_threads()
!$omp end single
!$omp end parallel

   block
      integer :: nargs
      integer :: iarg
      character(len=256) :: arg
      integer :: idx, istr_size
      character(len=2), parameter :: STR_SIZES(8) = ["kb", "k ", "mb", "m ", "gb", "g ", "tb", "t "]
      integer, parameter :: POWER_SIZES(8) = [1, 1, 2, 2, 3, 3, 4, 4]

      nargs = command_argument_count()
      iarg = 1
      do while (iarg <= nargs)

         ! Get current argument
         call read_and_check_next_arg(iarg, arg)

         select case (arg)
         case ("-debug")
            options%debug = .true.

         case ("-test")
            options%test = .true.

         case ("-env")
            info_env%show = .true.

         case ("-env-teams")
            ! Also show teams information
            ! Default to not show it since it gets quite verbose!
            info_env%teams = .true.
            info_env%show = .true.

         case ("-threads")

            if (iarg >= nargs) then
               write (ERROR_UNIT, *) "Too few arguments, -threads has no argument"
               stop 3
            end if

            ! Read next arg
            iarg = iarg + 1
            call read_and_check_next_arg(iarg, arg)

            read (arg, *) options%num_threads
            if (options%num_threads < 1) then
               write (ERROR_UNIT, *) "The number of threads *must* be 1 or more."
               stop 4
            end if

         case ("-kernel")

            if (iarg >= nargs) then
               write (ERROR_UNIT, *) "Too few arguments, -kernel has no argument"
               stop 3
            end if

            ! Read next arg
            iarg = iarg + 1
            call read_and_check_next_arg(iarg, arg)

            block
               character(len=len(arg)) :: left, right
               call split_comma(arg, left, right)
               if (len_trim(right) > 0) then
                  read (right, *) num_tasks
               end if
               ! Always remove everything right of comma :)
               arg = left
            end block

            if (associated(options%kernel)) then
               deallocate (options%kernel)
            end if

            select case (arg)
            case ("serial")
               allocate (option_kernel_serial_t::options%kernel)
            case ("manual")
               allocate (option_kernel_manual_t::options%kernel)
            case ("do")
               allocate (option_kernel_do_t::options%kernel)
            case ("do:simd")
               allocate (option_kernel_do_simd_t::options%kernel)
            case ("workshare")
               allocate (option_kernel_workshare_t::options%kernel)
               #:if defined("OMB_OMP_TASKLOOP")
                  case ("taskloop")
                  allocate (option_kernel_taskloop_t::options%kernel)
                  case ("taskloop:simd")
                  allocate (option_kernel_taskloop_simd_t::options%kernel)
               #:endif
            case ("loop")
               allocate (option_kernel_loop_t::options%kernel)
               #:if defined("OMB_OMP_TEAMS")
                  case ("teams:manual")
                  allocate (option_kernel_teams_manual_t::options%kernel)
                  #:if defined("OMB_OMP_TEAMS_DISTRIBUTE")
                     case ("teams:distribute")
                     allocate (option_kernel_teams_distribute_t::options%kernel)
                     case ("teams:distribute:do")
                     allocate (option_kernel_teams_distribute_do_t::options%kernel)
                  #:endif
                  #:if defined("OMB_OMP_TEAMS_PARALLEL")
                     case ("teams:parallel:manual")
                     allocate (option_kernel_teams_parallel_manual_t::options%kernel)
                     case ("teams:parallel:do")
                     allocate (option_kernel_teams_parallel_do_t::options%kernel)
                     case ("teams:parallel:loop")
                     allocate (option_kernel_teams_parallel_loop_t::options%kernel)
                  #:endif
               #:endif
            case default
               write (ERROR_UNIT, *) "The requested kernel does not exist?"
               write (ERROR_UNIT, *) " -kernel ", trim(arg)
               stop 4
            end select

            select type (kernel => options%kernel)
            class is (option_kernel_taskloop_t)
               kernel%num_tasks = num_tasks
            end select

         case ("fill")
            method = METHOD_FILL
            results%info%narrays = 1
            results%info%stores = 1
            results%info%reads = 0
            results%info%flop = 0

         case ("sum")
            method = METHOD_SUM
            results%info%narrays = 1
            results%info%stores = 0
            results%info%reads = 1
            results%info%flop = 1

         case ("add")
            method = METHOD_ADD
            results%info%narrays = 3
            results%info%stores = 1
            results%info%reads = 2
            results%info%flop = 1

         case ("copy")
            method = METHOD_COPY
            results%info%narrays = 2
            results%info%stores = 1
            results%info%reads = 1
            results%info%flop = 0

         case ("scale")
            method = METHOD_SCALE
            results%info%narrays = 2
            results%info%stores = 1
            results%info%reads = 1
            results%info%flop = 1

         case ("triadd", "triad")
            method = METHOD_TRIADD
            results%info%narrays = 3
            results%info%stores = 1
            results%info%reads = 2
            results%info%flop = 2

         case ("tetraadd", "tetra", "tetrad", "tetradd", "tetraad")
            method = METHOD_TETRADD
            results%info%narrays = 4
            results%info%stores = 1
            results%info%reads = 3
            results%info%flop = 2

         case ("pentaadd", "penta", "pentad", "pentadd", "pentaad")
            method = METHOD_PENTADD
            results%info%narrays = 5
            results%info%stores = 1
            results%info%reads = 4
            results%info%flop = 3

         case ("axpy", "daxpy", "saxpy")
            method = METHOD_AXPY
            results%info%narrays = 2
            results%info%stores = 1
            results%info%reads = 2
            results%info%flop = 2
            if (arg(1:1) == "d") then
               dtype = DTYPE_REAL64
            else if (arg(1:1) == "s") then
               dtype = DTYPE_REAL32
            end if

         case ("fs:triadd", "fs:triad")
            method = METHOD_FALSE_SHARING_TRIADD
            results%info%narrays = 3
            results%info%stores = 1
            results%info%reads = 2
            results%info%flop = 2

         case ("fs:tetraadd", "fs:tetra", "fs:tetradd", "fs:tetrad")
            method = METHOD_FALSE_SHARING_TETRADD
            results%info%narrays = 4
            results%info%stores = 1
            results%info%reads = 3
            results%info%flop = 2

         case ("-dtype")

            if (iarg >= nargs) then
               write (ERROR_UNIT, *) "Too few arguments, -dtype has no argument"
               stop 3
            end if

            ! Read next arg
            iarg = iarg + 1
            call read_and_check_next_arg(iarg, arg)

            select case (arg)
               #:if "real16" in REALS
                  case ("real16", "16", "halffloat", "halfsingle")
                  dtype = DTYPE_REAL16
               #:endif
            case ("real32", "32", "float", "single")
               dtype = DTYPE_REAL32

            case ("real64", "64", "double")
               dtype = DTYPE_REAL64

               #:if "real128" in REALS
                  case ("real128", "128", "doubledouble", "longdouble")
                  dtype = DTYPE_REAL128
               #:endif
            case default
               write (ERROR_UNIT, '(a)', advance="no") "-dtype argument is not one of "
               write (ERROR_UNIT, '(a)') "[${','.join(REALS)}$]"
               stop 3

            end select

         case ("-first-touch", "-ft")

            if (iarg >= nargs) then
               write (ERROR_UNIT, *) "Too few arguments, -first-touch has no argument"
               stop 3
            end if

            ! Read next arg
            iarg = iarg + 1
            call read_and_check_next_arg(iarg, arg)

            select case (arg)
            case ("parallel")
               options%first_touch = .true.
            case ("master")
               options%first_touch = .false.
            case default
               write (ERROR_UNIT, *) "-first-touch argument is not one of [parallel,master]"
               stop 3
            end select

         case ("-warmup")

            if (iarg >= nargs) then
               write (ERROR_UNIT, *) "Too few arguments, --warmup has no argument"
               stop 3
            end if

            ! Read next arg
            iarg = iarg + 1
            call read_and_check_next_arg(iarg, arg)

            read (arg, *) options%warmup_it
            if (options%warmup_it < 1) then
               write (ERROR_UNIT, *) "The number of warmup iterations *must* be 1 or more."
               stop 4
            end if

         case ("-it")

            if (iarg >= nargs) then
               write (ERROR_UNIT, *) "Too few arguments, --it has no argument"
               stop 3
            end if

            option_set_it = .true.
            ! Read next arg
            iarg = iarg + 1
            call read_and_check_next_arg(iarg, arg)

            read (arg, *) options%it
            if (options%it < 1) then
               write (ERROR_UNIT, *) "The number of iterations must be larger than 0!"
               stop 4
            end if

         case ("-n", "-s")

            if (iarg >= nargs) then
               write (ERROR_UNIT, *) "Too few arguments, -n/-s has no argument"
               stop 3
            end if

            ! Read next arg
            iarg = iarg + 1
            call read_and_check_next_arg(iarg, arg)

            ! Lower-case it (so kb == KB == kB).
            arg = lcase(trim(arg))

            block
               logical :: found

               found = .false.
               ! We need to check if kb/kB/k, mb/MB/m, gb/GB/g is in the arg
               do istr_size = 1, size(STR_SIZES)
                  idx = index(trim(arg), trim(STR_SIZES(istr_size)))
                  if (idx > 0) then
                     if (options%debug) then
                        write (OUTPUT_UNIT, *) "Converting", trim(arg)
                        write (OUTPUT_UNIT, *) "To unit = ", trim(STR_SIZES(istr_size))
                     end if

                     arg(idx:idx + 1) = " "
                     read (arg, *) bytes
                     ! this converts 10MB to
                     ! 10 * 1024**2
                     bytes = bytes*1024_int64**POWER_SIZES(istr_size)
                     found = .true.
                     exit
                  end if
               end do

               if (.not. found) then
                  write (ERROR_UNIT, *) "Could not interpret your -n argument: ", trim(arg)
                  stop 4
               end if

            end block

         case ("-padding", "-offset")
            ! we allow padding as it might be simpler to understand

            if (iarg >= nargs) then
               write (ERROR_UNIT, *) "Too few arguments, --offset has no argument"
               stop 3
            end if

            ! Read next arg
            iarg = iarg + 1
            call read_and_check_next_arg(iarg, arg)

            read (arg, *) options%offset
            if (options%offset < 0) then
               write (ERROR_UNIT, *) "The offset between arrays *must* be a positive number"
               stop 4
            end if

         case ("norun", "-dryrun")

            options%dryrun = .true.

         case ("help", "-help", "-h")

            call print_help()

            ! No need to stop (return will stop as well)
            return

         case default

            write (ERROR_UNIT, *) "Trying to parse argument ", iarg
            write (ERROR_UNIT, *) "Unknown argument: ", trim(arg)
            call print_help()
            stop 1

         end select

         iarg = iarg + 1
      end do

   end block

   block

      ! Correct OpenMP defaults
      character(len=256) :: arg
      integer :: i

      call get_environment_variable("OMP_SCHEDULE", arg, i)
      if (i <= 0) then
         ! schedule not set, do not rely on the implementation specific
         ! set it to static
         call omp_set_schedule(OMP_SCHED_STATIC, 0)
      end if

   end block

   ! Specify number of threads used
   call omp_set_num_threads(options%num_threads)

   if (.not. associated(options%kernel)) then
      ! default to the DO kernel
      allocate (option_kernel_do_t::options%kernel)
   end if

   #:if defined('OMB_MPI')
      if (rank_mpi > 0) then
         options%debug = .false.
      end if
   #:endif

   ! Generally, we will only use a single 2nd dimension.
   ! Only for false-sharing do we need a 2nd dimension.
   ! This will be set later
   results%info%N(2) = 1

   ! At this point, `bytes` is some size in bytes
   ! Lets convert this to the number of elements for the given dtype
   select case (dtype)
      #:if "real16" in REALS
         case (DTYPE_REAL16)
         results%info%bits = storage_size(1._real16)
      #:endif
   case (DTYPE_REAL32)
      results%info%bits = storage_size(1._real32)
   case (DTYPE_REAL64)
      results%info%bits = storage_size(1._real64)
      #:if "real128" in REALS
         case (DTYPE_REAL128)
         results%info%bits = storage_size(1._real128)
      #:endif
   case default
      write (ERROR_UNIT, *) "Unknown data-type!"
      stop 21
   end select

   ! Convert bits -> bytes
   if (mod(results%info%bits, 8) /= 0) then
      write (ERROR_UNIT, *) "The data-type bit size is not divisible by 8."
      write (ERROR_UNIT, *) "Currently not implemented!"
      stop 30
   end if

   if (options%debug) then
      write (OUTPUT_UNIT, debug_fmt_i) "target_bytes [B]", nint(bytes, int64)
   end if

   #:def CASE_DTYPE_BENCHMARK(name)
      select case (dtype)
         #:for real in REALS
            case (DTYPE_${real.upper()}$)
            benchmark => ${name}$_${real}$
         #:endfor
      end select
   #:enddef CASE_DTYPE_BENCHMARK

   select case (method)
   case (METHOD_ADD)
      method_str = "add"

      @:CASE_DTYPE_BENCHMARK(bench_add)

   case (METHOD_SCALE)
      method_str = "scale"

      @:CASE_DTYPE_BENCHMARK(bench_scale)

   case (METHOD_COPY)
      method_str = "copy"

      @:CASE_DTYPE_BENCHMARK(bench_copy)

   case (METHOD_TRIADD)
      method_str = "triad"

      @:CASE_DTYPE_BENCHMARK(bench_triadd)

   case (METHOD_TETRADD)
      method_str = "tetrad"

      @:CASE_DTYPE_BENCHMARK(bench_tetradd)

   case (METHOD_PENTADD)
      method_str = "pentad"

      @:CASE_DTYPE_BENCHMARK(bench_pentadd)

   case (METHOD_SUM)
      method_str = "sum"

      @:CASE_DTYPE_BENCHMARK(bench_sum)

   case (METHOD_AXPY)
      method_str = "axpy"

      @:CASE_DTYPE_BENCHMARK(bench_axpy)

   case (METHOD_FILL)
      method_str = "fill"

      @:CASE_DTYPE_BENCHMARK(bench_fill)

   case (METHOD_FALSE_SHARING_TRIADD)
      method_str = "fs:triad"

      results%info%N(2) = options%num_threads

      @:CASE_DTYPE_BENCHMARK(bench_false_sharing_triadd)

   case (METHOD_FALSE_SHARING_TETRADD)
      method_str = "fs:tetrad"

      results%info%N(2) = options%num_threads

      @:CASE_DTYPE_BENCHMARK(bench_false_sharing_tetradd)

   case default

      write (ERROR_UNIT, *) "No method defined, cannot run benchmark!"
      stop 10

   end select

   ! Adjust number of iterations based on the byte size.
   call results%info%correct_values(bytes)
   bytes = results%info%elements()*results%info%element_bytes()

   ! Determine if the counters are too small
   block
      integer(${OMB_INT_KIND}$) :: huge_N
      huge_N = huge(results%info%N(1))
      if (int(results%info%N(1), int64) + options%offset > huge_N .or. &
          product(int(results%info%N, int64)) > huge_N) then
         write (ERROR_UNIT, *) "Cannot store the array size in the variable, must use int64."
         write (ERROR_UNIT, *) "Please recompile the program with -DOMB_INT_KIND=int64 (the default)."
         stop 20
      end if
   end block

   ! For very small arrays, we should do more iterations to correctly
   ! So depends on whether the option has been set
   block
      real(real64) :: MB
      MB = results%info%MB()
      ! time the small memories.
      if (.not. option_set_it) then
         ! bump it up to more iterations for small memory footprints
         if (MB <= 5._real64) then
            options%it = 100
         end if
         if (MB <= 0.5_real64) then
            options%it = 500
         end if
         if (MB <= 0.125_real64) then
            options%it = 1000
         end if
      end if
   end block

   ! In case the kernel is the taskloop, and the num_tasks is < 1, then
   ! we must specify the correct number of tasks so there is a limited
   ! overhead of the task scheduling.
   select type (kernel => options%kernel)
   class is (option_kernel_taskloop_t)
      if (kernel%num_tasks < 1) then
         ! Decide a *good* number of tasks.
         ! For large counts of elements we should be able
         ! to split into ~10 tasks per thread.
         ! For very few elements, this might be too much.
         ! Hence we decide that a stride of 8 elements is a *good*
         ! choice. So task size should be ~8 for optimal perf.
         ! Therefore we take the minimum:
         !    min(elements/8, 10 *num_threads)
         if (results%info%N(1)/8 < 10*options%num_threads) then
            kernel%num_tasks = max(1, results%info%N(1)/8)
         else
            kernel%num_tasks = 10*options%num_threads
         end if
      end if
   end select

   ! At this point we should have:
   ! n == elements along the distributed array dimension (<= big_n)

   if (options%debug) then
      write (OUTPUT_UNIT, debug_fmt_i) "used_bytes [B]", &
         nint(results%info%MB()/bytes2MB, int64)
      write (OUTPUT_UNIT, debug_fmt_i) "elements_count", results%info%elements()
      block
         integer(int64) :: all_ibytes
         real(real64) :: all_mb
         all_mb = results%info%MB()
         all_ibytes = nint(all_mb/bytes2MB, int64)
         select case (all_ibytes)
         case (:1024_int64 - 1)
            write (OUTPUT_UNIT, debug_fmt_e) "alloc_memory [B]", all_mb*1024**2
         case (1024_int64**1:1024_int64**2 - 1)
            write (OUTPUT_UNIT, debug_fmt_e) "alloc_memory [kB]", all_mb*1024
         case (1024_int64**2:1024_int64**3 - 1)
            write (OUTPUT_UNIT, debug_fmt_e) "alloc_memory [MB]", all_mb
         case (1024_int64**3:1024_int64**4 - 1)
            write (OUTPUT_UNIT, debug_fmt_e) "alloc_memory [GB]", all_mb/1024
         case (1024_int64**4:)
            write (OUTPUT_UNIT, debug_fmt_e) "alloc_memory [TB]", all_mb/1024**2
         end select
      end block
      write (OUTPUT_UNIT, debug_fmt_a) "alloc_type", "${OMB_ALLOC_TYPE}$"
      write (OUTPUT_UNIT, debug_fmt_i) "num_threads", options%num_threads
      write (OUTPUT_UNIT, debug_fmt_i) "dtype_size [b]", results%info%bits
      write (OUTPUT_UNIT, debug_fmt_i) "dtype_size [B]", nint(results%info%element_bytes(), int32)
      write (OUTPUT_UNIT, debug_fmt_a) "method", trim(method_str)
      write (OUTPUT_UNIT, debug_fmt_i) "num_arrays", results%info%narrays
      write (OUTPUT_UNIT, debug_fmt_a, advance="no") "kernel"
      block
         character(len=32) :: name
         call options%kernel%name(name)
         write (OUTPUT_UNIT, "(a)") trim(name)
      end block
      select type (kernel => options%kernel)
      class is (option_kernel_taskloop_t)
         write (OUTPUT_UNIT, debug_fmt_i) "taskloop_num_tasks", kernel%num_tasks
      end select
      write (OUTPUT_UNIT, debug_fmt_l) "first_touch", options%first_touch
      write (OUTPUT_UNIT, debug_fmt_i) "warmup_iterations", options%warmup_it
      write (OUTPUT_UNIT, debug_fmt_i) "iterations", options%it
      write (OUTPUT_UNIT, debug_fmt_i) "offset", options%offset
      block
         integer(int64) :: all_ibytes
         real(real64) :: all_rbytes
         all_rbytes = options%offset*results%info%element_bytes()* &
                      results%info%narrays*results%info%N(2)
         all_ibytes = nint(all_rbytes, int64)
         select case (all_ibytes)
         case (:1024_int64 - 1)
            write (OUTPUT_UNIT, debug_fmt_e) "offset_memory [B]", all_rbytes
         case (1024_int64**1:1024_int64**2 - 1)
            write (OUTPUT_UNIT, debug_fmt_e) "offset_memory [kB]", all_rbytes/1024
         case (1024_int64**2:1024_int64**3 - 1)
            write (OUTPUT_UNIT, debug_fmt_e) "offset_memory [MB]", all_rbytes/1024**2
         case (1024_int64**3:)
            write (OUTPUT_UNIT, debug_fmt_e) "offset_memory [GB]", all_rbytes/1024**3
         end select
      end block
   end if

   ! OpenMP information
   if (info_env%show) then

      #:if defined('OMB_MPI')
         call show_info_mpi()
      #:else
         call show_info_omp()
      #:endif

   else if (.not. options%dryrun) then ! only run in this case

      if (options%test) then
         ! Ensure that the test output is consistent
         ! i.e. only 1 run for all methods!
         options%it = 1
      end if

      ! Allocate the timings
      call results%allocate(options%it)

      call benchmark(results%info%N(1), options, results)

      ! Reduce the results

      #:if defined('OMB_MPI')

         if (size_mpi > 1) then
            ! Only reduce, if we have more than 1 processor
            call results%reduce_mpi(results)
         end if

      #:endif

      if (rank_mpi == 0 .and. .not. options%test) then

         write (OUTPUT_UNIT, "(tr1,a,t12)", advance="no") trim(method_str)
         block
            character(len=32) :: name
            call options%kernel%name(name)
            write (OUTPUT_UNIT, "(tr1,a,t24)", advance="no") trim(name)
         end block
         if (options%first_touch) then
            ! parallel
            write (OUTPUT_UNIT, "(tr1,i1)", advance="no") 1
         else
            ! master
            write (OUTPUT_UNIT, "(tr1,i1)", advance="no") 0
         end if
         write (OUTPUT_UNIT, "(tr1,i2)", advance="no") results%info%bits/8
         write (OUTPUT_UNIT, "(tr1,es16.8)", advance="no") results%info%MB()
         write (OUTPUT_UNIT, "(tr1,es16.8)", advance="no") results%time_min()
         write (OUTPUT_UNIT, "(tr1,es16.8)", advance="no") results%time_avg()
         write (OUTPUT_UNIT, "(tr1,es16.8)", advance="no") results%time_std()
         write (OUTPUT_UNIT, "(tr1,es16.8)", advance="no") results%time_max()
         write (OUTPUT_UNIT, "(tr1,en16.8)", advance="no") results%bandwidth_gbs()
         write (OUTPUT_UNIT, "(tr1,en16.8)", advance="no") results%gflops()
         write (OUTPUT_UNIT, "(a)") ! line-break

         flush OUTPUT_UNIT

      end if
   end if !dryrun

   #:if defined('OMB_MPI')
      call MPI_Finalize(ierr_mpi)
   #:endif

contains

   subroutine read_and_check_next_arg(iarg, arg)
      integer, intent(in) :: iarg
      character(len=*), intent(inout) :: arg
      integer :: len_arg

      arg = " "
      call get_command_argument(iarg, arg, length=len_arg)

      if (len_arg > len(arg)) then
         write (ERROR_UNIT, "(a,tr1,i0,tr1,a)") "Argument", iarg, "is too long! (>256)"
         stop 2
      end if

      if (arg(1:2) == "--") then
         arg(1:len(arg) - 1) = arg(2:)
         arg(len(arg):len(arg)) = " "
      end if

   end subroutine

   subroutine split_comma(str, left, right)
      character(len=*), intent(in) :: str
      character(len=*), intent(out) :: left, right

      integer :: idx

      idx = index(str, ",")

      if (idx > 0) then
         left = str(1:idx - 1)
         right = str(idx + 1:)
      else
         left = str(:)
         right = " "
      end if

   end subroutine

   #:if defined('OMB_MPI')
      subroutine show_info_mpi()

         character(len=*), parameter :: mpi_fmt_i = "('mpi ',a,t35,':',256(tr1,i0))"

         ! This basically loops show_info_omp for each rank
         integer :: rank

         do rank = 0, size_mpi - 1
            flush OUTPUT_UNIT

            if (rank == rank_mpi) then
               if (rank == 0) then
                  write (OUTPUT_UNIT, mpi_fmt_i) "comm_size", size_mpi
               end if
               write (OUTPUT_UNIT, mpi_fmt_i, advance="no") "comm_rank", rank_mpi
               call show_info_omp()
               write (OUTPUT_UNIT, *) ! empty line
               flush OUTPUT_UNIT
            end if

            call MPI_Barrier(MPI_COMM_WORLD)

            flush OUTPUT_UNIT

         end do

      end subroutine
   #:endif

   subroutine show_info_omp()
      use info_omp_m, only: print_info_sys
      use info_omp_m, only: print_info_omp

      write (OUTPUT_UNIT, *) ! newline

      call print_info_sys()

      call print_info_omp(info_env)

      write (OUTPUT_UNIT, *) ! newline

   end subroutine

   pure function lcase(str)
      character(len=*), intent(in) :: str
      character(len=len(str)) :: lcase
      character(len=*), parameter :: upper = 'ABCDEFGHIJKLMNOPQRSTUVWXYZ'
      character(len=*), parameter :: lower = 'abcdefghijklmnopqrstuvwxyz'

      integer :: ic, i

      ! Capitalize each letter if it is lowercase
      lcase = str
      i = scan(lcase, upper)
      do while (i > 0)
         ! Get the conversion index
         ic = index(upper, lcase(i:i))
         lcase(i:i) = lower(ic:ic)
         ic = scan(lcase(i + 1:), upper)
         if (ic > 0) then
            i = i + ic
         else
            i = 0
         end if
      end do

   end function lcase

   subroutine print_help()

      character(len=256) :: arg
      integer :: len_arg

      character(len=*), parameter :: fmt_opt_a = "(t3,'--',a,t18,': ',a)"
      character(len=*), parameter :: fmt_oa = "(t18,'  ',a)"
      character(len=*), parameter :: fmt_oafa = "(t18,'  ',a,tr1,f0.1,tr1,a)"
      character(len=*), parameter :: fmt_arg_a = "(t3,'  ',a,t18,': ',a)"
      character(len=*), parameter :: fmt_aa = "(t18,'  ',a)"
      character(len=*), parameter :: fmt_nl = "(a)"

      ! Get executable name
      call get_command_argument(0, arg, length=len_arg)
      write (OUTPUT_UNIT, '(2a)') "OpenMP benchmark program: ", trim(arg)
      write (OUTPUT_UNIT, fmt_nl)
      write (OUTPUT_UNIT, '(a)') "STREAM like OpenMP benchmark program written in fortran."
      write (OUTPUT_UNIT, fmt_nl)

      write (OUTPUT_UNIT, '(a)') "Methods:"
      write (OUTPUT_UNIT, fmt_arg_a) "triad", "a = b + c*2  [default]"
      write (OUTPUT_UNIT, fmt_arg_a) "tetrad", "a = b + c*d"
      write (OUTPUT_UNIT, fmt_arg_a) "pentad", "a = b*c + d*e"
      write (OUTPUT_UNIT, fmt_arg_a) "axpy", "a = a + b*2"
      write (OUTPUT_UNIT, fmt_arg_a) "scale", "a = b*2"
      write (OUTPUT_UNIT, fmt_arg_a) "add", "a = b + c"
      write (OUTPUT_UNIT, fmt_arg_a) "fill", "a = 2."
      write (OUTPUT_UNIT, fmt_arg_a) "sum", "res = sum(a)"
      write (OUTPUT_UNIT, fmt_arg_a) "copy", "a = b"
      write (OUTPUT_UNIT, fmt_arg_a) "fs:triad", "a = b + c*2"
      write (OUTPUT_UNIT, fmt_aa) "false-sharing access."
      write (OUTPUT_UNIT, fmt_arg_a) "fs:tetrad", "a = b + c*d"
      write (OUTPUT_UNIT, fmt_aa) "false-sharing access."

      write (OUTPUT_UNIT, fmt_nl)
      write (OUTPUT_UNIT, '(a)') "Options:"

      write (OUTPUT_UNIT, fmt_opt_a) "s/size/n", "the size of all arrays involved in the method"
      write (OUTPUT_UNIT, fmt_oa) "E.g. --size 2kB will allocate 2kB of memory."
      write (OUTPUT_UNIT, fmt_oa) "Understands kB, MB, GB and TB."
      write (OUTPUT_UNIT, fmt_oa) "The actual size will be aligned to 16 bytes."
      write (OUTPUT_UNIT, fmt_oafa) "Default is", DEFAULT_BYTES/1024**3, "GB."
      write (OUTPUT_UNIT, fmt_nl)

      write (OUTPUT_UNIT, fmt_opt_a) "kernel", "how the OpenMP distribution is done"
      write (OUTPUT_UNIT, fmt_oa) " - do -> use parallel do clause [default]"
      write (OUTPUT_UNIT, fmt_oa) " - do:simd -> use parallel do simd clause"
      write (OUTPUT_UNIT, fmt_oa) " - manual -> use parallel clause, static manual split"
      write (OUTPUT_UNIT, fmt_oa) " - workshare -> use parallel workshare clause"
      write (OUTPUT_UNIT, fmt_oa) "   lhs-realloc is explicitly prohibited by a(:) = ..."
      #:if defined("OMB_OMP_TASKLOOP")
         write (OUTPUT_UNIT, fmt_oa) " - taskloop[,num_tasks] -> use parallel taskloop clause"
         write (OUTPUT_UNIT, fmt_oa) "   default num_tasks lets each thread get ~10 tasks or tasks of min size 8"
         write (OUTPUT_UNIT, fmt_oa) " - taskloop:simd[,num_tasks] -> use parallel taskloop simd clause"
      #:endif
      write (OUTPUT_UNIT, fmt_oa) " - loop -> use the parallel loop workshare clause"
      #:if defined("OMB_OMP_TEAMS")
         #:if defined("OMB_OMP_TEAMS_PARALLEL")
            write (OUTPUT_UNIT, fmt_oa) " - teams:parallel:manual -> abuse the teams parallel workshare clause"
            write (OUTPUT_UNIT, fmt_oa) " - teams:parallel:do -> abuse the teams parallel do workshare clause"
            write (OUTPUT_UNIT, fmt_oa) " - teams:parallel:loop-> abuse the teams parallel loop workshare clause"
         #:endif
         write (OUTPUT_UNIT, fmt_oa) " - teams:manual -> abuse the teams workshare clause"
         #:if defined("OMB_OMP_TEAMS_DISTRIBUTE")
            write (OUTPUT_UNIT, fmt_oa) " - teams:distribute -> abuse the teams distribute workshare clause"
            write (OUTPUT_UNIT, fmt_oa) "   expect poor perf. due to bad teams distribution."
            write (OUTPUT_UNIT, fmt_oa) " - teams:distribute:do -> abuse the teams distribute parallel do workshare clause"
         #:endif
      #:endif
      write (OUTPUT_UNIT, fmt_oa) " - serial -> for testing the serial performance"
      write (OUTPUT_UNIT, fmt_nl)

      write (OUTPUT_UNIT, fmt_opt_a) "it", "how many iterations are done with timing"
      write (OUTPUT_UNIT, fmt_oa) "Default is 1000<128kB, 500<0.5MB, 100<5MB."
      write (OUTPUT_UNIT, fmt_nl)

      write (OUTPUT_UNIT, fmt_opt_a) "dtype", "which data-type to use"
      #:if "real16" in REALS
         write (OUTPUT_UNIT, fmt_oa) " - 16|real16 -> 2-byte real"
      #:endif
      write (OUTPUT_UNIT, fmt_oa) " - 32|real32 -> 4-byte real"
      write (OUTPUT_UNIT, fmt_oa) " - 64|real64 -> 8-byte real [default]"
      #:if "real128" in REALS
         write (OUTPUT_UNIT, fmt_oa) " - 128|real128 -> 16-byte real"
      #:endif
      write (OUTPUT_UNIT, fmt_nl)

      write (OUTPUT_UNIT, fmt_opt_a) "first-touch", "how to initialize arrays"
      write (OUTPUT_UNIT, fmt_oa) " - parallel -> initialize array in parallel [default]"
      write (OUTPUT_UNIT, fmt_oa) " - master -> initialize array with master thread"
      write (OUTPUT_UNIT, fmt_nl)

      write (OUTPUT_UNIT, fmt_opt_a) "warmup", "how many warm-up iterations are done before timing"
      write (OUTPUT_UNIT, fmt_oa) "A parallel do construct will be used, regardless of kernel."
      write (OUTPUT_UNIT, fmt_oa) "Default is 1."
      write (OUTPUT_UNIT, fmt_nl)

      write (OUTPUT_UNIT, fmt_opt_a) "offset", "number of elements added to each array for offsetting allocations"
      write (OUTPUT_UNIT, fmt_oa) "The offset elements are not iterated."
      write (OUTPUT_UNIT, fmt_oa) "Default is 0 elements."
      write (OUTPUT_UNIT, fmt_opt_a) "padding", "(alias for offset)"
      write (OUTPUT_UNIT, fmt_nl)

      write (OUTPUT_UNIT, fmt_opt_a) "threads", "number of threads used (supersedes OMP_NUM_TRHEADS)"
      write (OUTPUT_UNIT, fmt_nl)

      write (OUTPUT_UNIT, fmt_opt_a) "debug", "print-out additional debug information"
      write (OUTPUT_UNIT, fmt_opt_a) "test", "print-out testing variables to assert method runs correctly."
      write (OUTPUT_UNIT, fmt_oa) "Should output '0 0' for all method+kernels. Please bug-report if this is not the case."

      write (OUTPUT_UNIT, fmt_opt_a) "env", "print-out OpenMP environment understanding"
      write (OUTPUT_UNIT, fmt_oa) "Will print a lot of information related to how"
      write (OUTPUT_UNIT, fmt_oa) "OpenMP can place its threads."
      write (OUTPUT_UNIT, fmt_opt_a) "env-teams", "also print-out information for each team"
      write (OUTPUT_UNIT, fmt_nl)

      write (OUTPUT_UNIT, fmt_nl)
      write (OUTPUT_UNIT, fmt_nl) "Examples:"
      write (OUTPUT_UNIT, fmt_nl)
      write (OUTPUT_UNIT, fmt_nl) "  "//trim(arg)//" -n 2MB axpy"
      write (OUTPUT_UNIT, fmt_nl)
      write (OUTPUT_UNIT, fmt_nl) "runs the axpy code, using 3 arrays totalling 2MB of memory."

      write (OUTPUT_UNIT, fmt_nl)
      write (OUTPUT_UNIT, fmt_nl) "  "//trim(arg)//" -first-touch master " &
         &//"-kernel taskloop,32 -dtype 32 -n 2GB triad -it 200 -warmup 2"
      write (OUTPUT_UNIT, fmt_nl)
      write (OUTPUT_UNIT, fmt_nl) "runs the triad method using the taskloop kernel, " &
         &//"num_tasks of 32, 4-byte reals, 3 arrays of total 2GB,"
      write (OUTPUT_UNIT, fmt_nl) "running 2 warmup iterations, then 200 iterations, " &
         &//"with serial first-touch of the arrays."

      write (OUTPUT_UNIT, fmt_nl)
      write (OUTPUT_UNIT, fmt_nl) "Notes:"
      write (OUTPUT_UNIT, fmt_nl) "If OMP_SCHEDULE is unset, it will default to OMP_SCHEDULE=static,0"

      write (OUTPUT_UNIT, fmt_nl)
      write (OUTPUT_UNIT, fmt_nl)

      write (OUTPUT_UNIT, fmt_nl) "Running the benchmark routine returns data in the following ordering of columns:"
      write (OUTPUT_UNIT, fmt_nl)
      block
         character(len=*), parameter :: fmt_col = "(t2,a,t15,' : ',a)"

         write (OUTPUT_UNIT, fmt_col) "METHOD", "name of the method running"
         write (OUTPUT_UNIT, fmt_col) "KERNEL", "which OpenMP kernel used"
         write (OUTPUT_UNIT, fmt_col) "FIRST_TOUCH", "0 for master thread first-touch, 1 for distributed first-touch"
         write (OUTPUT_UNIT, fmt_col) "ELEM_B", "number of bytes per element in the array [B]"
         write (OUTPUT_UNIT, fmt_col) "MEM_MB", "size of all allocated arrays [MB]"
         write (OUTPUT_UNIT, fmt_col) "TIME_MIN", "minimum runtime of iterations [s]"
         write (OUTPUT_UNIT, fmt_col) "TIME_AVG", "average runtime of iterations [s]"
         write (OUTPUT_UNIT, fmt_col) "TIME_STD", "Bessel corrected standard deviation of runtime [s]"
         write (OUTPUT_UNIT, fmt_col) "TIME_MAX", "maximum runtime of iterations [s]"
         write (OUTPUT_UNIT, fmt_col) "BANDWIDTH_GBS", "maxmimum bandwidth using TIME_MIN [GB/s]"
         write (OUTPUT_UNIT, fmt_col) "GFLOPS", "maxmimum FLOPS using TIME_MIN [G/s]"
      end block

   end subroutine

end program
